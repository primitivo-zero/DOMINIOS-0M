<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameTok - ¡Tu plataforma de juegos!</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Estilos generales y reseteo */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-tap-highlight-color: transparent; /* Elimina el resaltado azul al tocar en móviles */
        }

        body {
            background-color: #000;
            color: #fff;
            overflow: hidden; /* Evita el scroll del body */
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.5s ease;
        }

        /* --- Centrado Global para todos los paneles --- */
        #main-menu, .container, #auth-modal {
            position: absolute; /* Para que ocupen todo el espacio y puedan superponerse */
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column; /* Por defecto para apilar contenido */
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Evita barras de scroll internas a menos que se necesiten */
        }

        /* --- Menú de Inicio --- */
        #main-menu {
            background: linear-gradient(135deg, #1a0033, #000);
            z-index: 200;
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        #main-menu.hidden {
            opacity: 0;
            transform: translateY(-100vh);
            pointer-events: none; /* Deshabilita interacciones cuando está oculto */
        }

        #gametok-title {
            font-size: 8vw; /* Responsive font size */
            font-weight: bold;
            color: #ff0050;
            text-shadow: 0 0 20px rgba(255, 0, 80, 0.7);
            margin-bottom: 50px;
            animation: pulse 2s infinite alternate;
        }

        @keyframes pulse {
            from {
                transform: scale(1);
            }
            to {
                transform: scale(1.05);
            }
        }

        #game-carousel-container {
            width: 80%;
            height: 300px; /* Altura fija para el carrusel */
            perspective: 1000px; /* Para el efecto 3D */
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 50px;
            position: relative; /* Para posicionar el carrusel */
        }

        #game-carousel {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d; /* Permite transformar elementos hijos en 3D */
            animation: rotateCarousel 30s infinite linear; /* Animación de rotación */
        }

        @keyframes rotateCarousel {
            from {
                transform: rotateY(0deg);
            }
            to {
                transform: rotateY(360deg);
            }
        }

        .carousel-item {
            position: absolute;
            width: 200px; /* Tamaño de los ítems del carrusel */
            height: 150px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            opacity: 0.9;
            backface-visibility: hidden; /* Para que no se vea el reverso */
            cursor: pointer;
            transition: transform 0.5s ease, opacity 0.5s ease;
            user-select: none; /* Evita que el texto se seleccione al hacer clic */
        }

        .carousel-item img {
            max-width: 80%;
            max-height: 80%;
            object-fit: contain;
            margin-bottom: 5px;
        }

        /* Los transforms de cada item serán generados por JS */

        #start-button {
            padding: 15px 30px;
            font-size: 1.5em;
            font-weight: bold;
            background-color: #ff0050;
            color: #fff;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(255, 0, 80, 0.5);
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        #start-button:hover {
            background-color: #ff3373;
            transform: translateY(-3px);
        }

        /* --- Login / Register Pop-up --- */
        .auth-modal {
            display: none; /* Oculto por defecto */
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 201; /* Por encima del menú principal */
        }

        .auth-modal-content {
            background-color: #1a1a1a;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
            text-align: center;
            width: 90%;
            max-width: 450px;
            position: relative;
            transform: scale(0.9); /* Pequeña animación de entrada */
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .auth-modal.show .auth-modal-content {
            transform: scale(1);
            opacity: 1;
        }


        .close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-button:hover,
        .close-button:focus {
            color: #fff;
            text-decoration: none;
        }

        .auth-modal-content h2 {
            margin-bottom: 25px;
            color: #ff0050;
            font-size: 2em;
        }

        .auth-modal-content input {
            width: calc(100% - 20px);
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #333;
            border-radius: 8px;
            background-color: #0d0d0d;
            color: #fff;
            font-size: 1em;
        }

        .auth-modal-content input::placeholder {
            color: #777;
        }

        .auth-modal-content button {
            width: calc(100% - 20px);
            padding: 12px;
            background-color: #ff0050;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        .auth-modal-content button:hover {
            background-color: #ff3373;
        }

        .auth-modal-content p {
            margin-top: 20px;
            font-size: 0.9em;
            color: #ccc;
        }

        .auth-modal-content p a {
            color: #ff0050;
            text-decoration: none;
            font-weight: bold;
        }

        /* --- Header / UI General (Juego) --- */
        .header {
            position: fixed; /* Fijo en la parte superior */
            top: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center; /* Centrar verticalmente */
            padding: 15px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), rgba(0,0,0,0));
            z-index: 100;
            display: none; /* Oculto inicialmente */
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: #ff0050;
        }

        .search-icon, .upload-icon {
            font-size: 20px;
            margin: 0 10px;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .search-icon:hover, .upload-icon:hover {
            color: #ff0050;
        }

        .container {
            display: none; /* Oculto inicialmente */
            /* Se superpone y toma el control cuando se inicia sesión */
            position: relative; /* Para posicionar los slides dentro */
            overflow: hidden; /* MUY IMPORTANTE para el efecto TikTok */
        }

        #game-slides-container {
            width: 100%;
            height: 100%;
            position: relative; /* Para los slides absolutos */
            transition: transform 0.5s ease-in-out; /* Animación de desplazamiento vertical */
        }

        .game-slide {
            position: absolute;
            top: 0; /* Cada slide se posiciona en 0,0 y el contenedor se desplaza */
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column; /* Contenido apilado */
            justify-content: center; /* Centrar verticalmente */
            align-items: center; /* Centrar horizontalmente */
            background-size: cover;
            background-position: center;
            overflow: hidden; /* Por si el contenido del juego es grande */
            /* Cada slide se moverá con el transform del padre, no necesita su propio transform */
        }

        .game-content-wrapper {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0,0,0,0.6); /* Fondo semi-transparente para el juego */
            padding-bottom: 80px; /* Espacio para el indicador y side-buttons */
        }

        .game-info {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            max-width: 90%;
            margin-bottom: 20px; /* Separación del área de juego */
            text-align: center;
        }

        .game-title {
            font-size: 28px;
            margin-bottom: 10px;
            color: #fff;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .game-desc {
            font-size: 16px;
            margin-bottom: 15px;
            color: #ddd;
        }

        .controls-info {
            font-size: 14px;
            margin-bottom: 10px;
            color: #aaa;
        }

        .control-buttons {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }

        .control-btn {
            background-color: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background-color: rgba(255,255,255,0.4);
        }

        .play-btn {
            background-color: #ff0050;
        }

        .play-btn:hover {
            background-color: #ff3373;
        }

        .game-play-area {
            /* Contenedor para el contenido específico de cada juego */
            display: flex;
            justify-content: center;
            align-items: center;
            /* Flexibilidad para el tamaño, pero se puede fijar si el juego lo requiere */
        }

        /* --- Botones laterales (Likes, Comentarios, Compartir) --- */
        .side-buttons {
            position: fixed;
            right: 15px;
            bottom: 100px; /* Ajuste para no superponer con el indicador */
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 50;
        }

        .side-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
            cursor: pointer;
        }

        .side-icon {
            background-color: rgba(255,255,255,0.1);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 5px;
            font-size: 20px;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .side-icon.liked {
            color: #ff0050;
        }

        .side-icon:hover {
            background-color: rgba(255,255,255,0.3);
        }

        .side-text {
            font-size: 12px;
            color: #ccc;
        }

        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #ff0050;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            margin-bottom: 5px;
            border: 2px solid white;
        }

        /* --- Indicadores de juego --- */
        .game-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            z-index: 100;
        }

        .indicator-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: rgba(255,255,255,0.5);
            margin: 0 5px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .indicator-dot.active {
            background-color: #ff0050;
            transform: scale(1.2);
        }

        /* --- Controles Móviles (Teclado virtual) --- */
        .mobile-controls {
            display: none; /* Oculto por defecto, se muestra con media query */
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 25vh; /* Aproximadamente un cuarto de la pantalla */
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 90;
            justify-content: space-around; /* Distribuir elementos */
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
            border-top-left-radius: 15px;
            border-top-right-radius: 15px;
        }

        .mobile-controls .d-pad-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            width: 180px; /* Tamaño fijo para el d-pad */
            height: 180px;
        }

        .mobile-btn {
            background-color: rgba(255,255,255,0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            user-select: none;
            -webkit-user-select: none;
            transition: background-color 0.2s ease;
            cursor: pointer;
        }

        .mobile-btn:active {
            background-color: rgba(255,255,255,0.4);
        }

        /* Posicionamiento en el grid del D-pad */
        .d-pad-group .mobile-btn[data-control="up"] { grid-area: 1 / 2 / 2 / 3; }
        .d-pad-group .mobile-btn[data-control="left"] { grid-area: 2 / 1 / 3 / 2; }
        .d-pad-group .mobile-btn[data-control="right"] { grid-area: 2 / 3 / 3 / 4; }
        .d-pad-group .mobile-btn[data-control="down"] { grid-area: 3 / 2 / 4 / 3; }
        /* El centro se mantiene vacío */
        .d-pad-group div:nth-child(5) { grid-area: 2 / 2 / 3 / 3; visibility: hidden; }


        .action-button-group {
            display: flex;
            gap: 15px;
        }

        .mobile-btn.action-btn {
            background-color: #ff0050;
            border-radius: 50%; /* Acción principal circular */
            width: 80px; /* Tamaño del botón de acción */
            height: 80px;
            font-size: 1.8em;
        }

        .mobile-btn.action-btn:active {
            background-color: #ff3373;
        }

        /* --- Media Queries para Móviles --- */
        @media (max-width: 768px) {
            #gametok-title {
                font-size: 12vw;
            }
            #game-carousel-container {
                height: 200px;
            }
            .carousel-item {
                width: 150px;
                height: 100px;
                font-size: 1.2em;
            }

            .game-content-wrapper {
                /* Para que el juego y la info tengan espacio cuando los controles estén */
                padding-bottom: calc(25vh + 80px); /* Altura de controles + padding para side-buttons */
            }

            .side-buttons {
                bottom: calc(25vh + 15px); /* Ajuste para no superponer con controles */
                right: 10px;
            }

            .mobile-controls {
                display: flex; /* Mostrar controles móviles */
            }
        }

        /* --- Estilos específicos de juegos (los que ya tenías) --- */
        #game1 { background: linear-gradient(135deg, #ff0050, #8400ff); } /* Memoria */
        #game2 { background: linear-gradient(135deg, #00ffaa, #0084ff); } /* Serpiente */
        #game3 { background: linear-gradient(135deg, #ffaa00, #ff0050); } /* Pong */
        #game4 { background: linear-gradient(135deg, #8400ff, #00ffaa); } /* Flappy Bird */
        #game5 { background: linear-gradient(135deg, #0084ff, #ffaa00); } /* Breakout */


        /* Estilos de las áreas de juego */
        .memory-game {
            display: grid;
            grid-template-columns: repeat(4, 70px); /* Más pequeño para centrar mejor */
            grid-gap: 8px;
            background-color: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 10px;
        }

        .memory-card {
            width: 70px;
            height: 70px;
            background-color: rgba(255,255,255,0.2);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
            transform-style: preserve-3d; /* Para el efecto de volteo 3D */
            position: relative;
        }
        .memory-card .front, .memory-card .back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden; /* Oculta la cara trasera al voltear */
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
        }
        .memory-card .back {
            background-color: white;
            color: #333;
            transform: rotateY(180deg); /* La cara trasera está volteada inicialmente */
        }
        .memory-card.flipped {
            transform: rotateY(180deg); /* Voltea la tarjeta para mostrar la cara trasera */
        }
        .memory-card.matched .front, .memory-card.matched .back {
            opacity: 0.5;
        }

        #snake-game, #pong-game, #flappy-game, #breakout-game {
            display: flex;
            justify-content: center;
            align-items: center;
            width: auto; /* Dejar que el canvas/contenido interno defina el ancho */
            height: auto; /* Dejar que el canvas/contenido interno defina el alto */
            max-width: 95vw; /* Limitar para móviles */
            max-height: 50vh; /* Limitar para móviles, dejando espacio a info y controles */
            border-radius: 5px;
            overflow: hidden; /* Por si el juego tiene elementos que se salen */
        }

        #snake-canvas {
            background-color: #333; /* Fondo del canvas de la serpiente */
            border-radius: 5px;
        }

        #pong-game {
            width: 400px;
            height: 250px;
            position: relative;
            background-color: rgba(0,0,0,0.2);
        }

        .paddle {
            position: absolute;
            width: 15px;
            height: 80px;
            background-color: white;
        }

        #left-paddle { left: 10px; }
        #right-paddle { right: 10px; }

        .ball {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: white;
            border-radius: 50%;
        }

        .score {
            position: absolute;
            top: 10px;
            font-size: 24px;
            color: white;
            z-index: 10;
        }

        #left-score { left: 150px; }
        #right-score { right: 150px; }

        #flappy-game {
            width: 300px;
            height: 400px;
            position: relative;
            background-color: #70c5ce;
        }

        #bird {
            position: absolute;
            width: 40px;
            height: 30px;
            background-color: #ffcc00;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
        }

        .pipe {
            position: absolute;
            width: 60px;
            background-color: #74BF2E;
        }

        .pipe.top { top: 0; }
        .pipe.bottom { bottom: 0; }

        #breakout-canvas {
            background-color: #333;
            border-radius: 5px;
        }

    </style>
</head>
<body>

    <div id="main-menu">
        <h1 id="gametok-title">GameTok</h1>
        <div id="game-carousel-container">
            <div id="game-carousel">
                </div>
        </div>
        <button id="start-button">Comenzar</button>
    </div>

    <div class="container">
        <div class="header">
            <div class="logo">GameTok</div>
            <div>
                <i class="fas fa-search search-icon"></i>
                <i class="fas fa-cloud-upload-alt upload-icon"></i>
            </div>
        </div>

        <div id="game-slides-container">
            </div>

        <div class="side-buttons">
            <div class="side-button">
                <div class="avatar">U</div> <span class="side-text">Usuario</span>
            </div>
            <div class="side-button" id="like-button">
                <div class="side-icon"><i class="fas fa-heart"></i></div>
                <span class="side-text" id="likes-count">0</span>
            </div>
            <div class="side-button">
                <div class="side-icon"><i class="fas fa-comment-dots"></i></div>
                <span class="side-text">Comentarios</span>
            </div>
            <div class="side-button">
                <div class="side-icon"><i class="fas fa-share"></i></div>
                <span class="side-text">Compartir</span>
            </div>
        </div>

        <div class="game-indicator">
            </div>

        <div class="mobile-controls">
            <div class="d-pad-group">
                <div class="mobile-btn" data-control="up"><i class="fas fa-arrow-up"></i></div>
                <div class="mobile-btn" data-control="left"><i class="fas fa-arrow-left"></i></div>
                <div class="mobile-btn" data-control="right"><i class="fas fa-arrow-right"></i></div>
                <div class="mobile-btn" data-control="down"><i class="fas fa-arrow-down"></i></div>
                <div class="mobile-btn" style="visibility: hidden;"></div> </div>
            <div class="action-button-group">
                <div class="mobile-btn action-btn" data-control="action1"><i class="fas fa-hand-pointer"></i></div>
                <div class="mobile-btn action-btn" data-control="action2"><i class="fas fa-redo"></i></div>
            </div>
        </div>

    </div>

    <div id="auth-modal" class="auth-modal">
        <div class="auth-modal-content">
            <span class="close-button">&times;</span>
            <h2 id="auth-title">Iniciar Sesión</h2>
            <input type="text" id="username" placeholder="Nombre de usuario" required>
            <input type="password" id="password" placeholder="Contraseña" required>
            <button id="auth-submit-button">Iniciar Sesión</button>
            <p>¿No tienes una cuenta? <a href="#" id="toggle-auth">Regístrate aquí</a></p>
        </div>
    </div>

    <script>
        // Datos de los juegos
        const games = [
            {
                id: 'game1',
                name: 'Memoria',
                description: '¡Pon a prueba tu memoria con este divertido juego de cartas! Encuentra las parejas en el menor tiempo posible.',
                controls: 'Clic/Toque para voltear las cartas. (ASWD no aplica)',
                gameContent: '<div class="memory-game"></div>'
            },
            {
                id: 'game2',
                name: 'Serpiente',
                description: 'Alimenta a la serpiente y hazla crecer sin chocar contra las paredes o su propio cuerpo. ¡Cada manzana te hace más largo!',
                controls: 'Teclas ASWD para mover la serpiente. D-Pad en móviles.',
                gameContent: '<div id="snake-game"><canvas id="snake-canvas" width="300" height="300"></canvas></div>'
            },
            {
                id: 'game3',
                name: 'Pong',
                description: 'El clásico juego de ping-pong. Mueve tu paleta izquierda para golpear la pelota y evitar que tu oponente anote.',
                controls: 'Teclas WS para mover la paleta izquierda. D-Pad arriba/abajo en móviles.',
                gameContent: '<div id="pong-game"><div class="paddle" id="left-paddle"></div><div class="paddle" id="right-paddle"></div><div class="ball"></div><div class="score" id="left-score">0</div><div class="score" id="right-score">0</div></div>'
            },
            {
                id: 'game4',
                name: 'Flappy Bird',
                description: 'Ayuda al pájaro a volar a través de los obstáculos. ¡Cada tubería es un punto, pero cuidado con chocarte!',
                controls: 'Espacio o clic/toque para aletear. Botón de Acción en móviles.',
                gameContent: '<div id="flappy-game"><div id="bird"></div></div>'
            },
            {
                id: 'game5',
                name: 'Breakout',
                description: 'Destruye todos los bloques con tu pelota y paleta. ¡Sé preciso para limpiar el tablero!',
                controls: 'Teclas AD para mover la paleta. D-Pad izquierda/derecha en móviles.',
                gameContent: '<div id="breakout-game"><canvas id="breakout-canvas" width="400" height="300"></canvas></div>'
            }
        ];

        let currentActiveGame = 0; // Índice del juego actual
        let isAuthModalOpen = false;
        let isMobile = window.innerWidth <= 768; // Para detectar si es móvil
        let isGameTransitioning = false; // Flag para evitar spam de navegación durante la transición

        // Referencias a elementos del DOM
        const mainMenu = document.getElementById('main-menu');
        const startButton = document.getElementById('start-button');
        const authModal = document.getElementById('auth-modal');
        const closeAuthButton = authModal.querySelector('.close-button');
        const toggleAuthLink = document.getElementById('toggle-auth');
        const authTitle = document.getElementById('auth-title');
        const authSubmitButton = document.getElementById('auth-submit-button');
        const gameCarousel = document.getElementById('game-carousel');
        const gameSlidesContainer = document.getElementById('game-slides-container');
        const gameIndicator = document.querySelector('.game-indicator');
        const appContainer = document.querySelector('.container');
        const header = document.querySelector('.header');
        const likeButton = document.getElementById('like-button');
        const likesCount = document.getElementById('likes-count');
        const mobileControls = document.querySelector('.mobile-controls');


        // --- Funciones del Menú de Inicio y Carrusel ---

        // Genera los ítems del carrusel dinámicamente
        function generateCarouselItems() {
            const numGames = games.length;
            const angleStep = 360 / numGames;
            const radius = 300; // Radio de la órbita del carrusel

            gameCarousel.innerHTML = ''; // Limpiar carrusel existente

            games.forEach((game, index) => {
                const carouselItem = document.createElement('div');
                carouselItem.classList.add('carousel-item');
                carouselItem.innerHTML = `<span>${game.name}</span>`; // Por ahora solo el nombre

                carouselItem.setAttribute('data-game-id', game.id);

                // Calcular la transformación para distribuir uniformemente
                // Posicionar con rotateY y translateZ para el efecto 3D
                const transformValue = `rotateY(${index * angleStep}deg) translateZ(${radius}px)`;
                carouselItem.style.transform = transformValue;
                // Asigna colores aleatorios al carrusel para que se vea más dinámico
                carouselItem.style.background = `linear-gradient(45deg, ${getRandomColor()}, ${getRandomColor()})`;

                carouselItem.addEventListener('click', () => {
                    // Centrar el juego seleccionado en el carrusel al hacer clic
                    // Se calcula el ángulo necesario para que el elemento rote al frente
                    const targetAngle = -(index * angleStep);
                    gameCarousel.style.transition = 'transform 0.8s ease-in-out';
                    gameCarousel.style.transform = `rotateY(${targetAngle}deg)`;
                    gameCarousel.style.animationPlayState = 'paused'; // Pausar la animación automática

                    // Reanudar la animación después de un tiempo si no hay otra interacción
                    setTimeout(() => {
                        gameCarousel.style.transition = ''; // Resetear transición para que la animación automática funcione
                        gameCarousel.style.animationPlayState = 'running';
                    }, 2500); // Reanudar después de 2.5 segundos
                });

                gameCarousel.appendChild(carouselItem);
            });
        }

        // Genera los slides de los juegos y los indicadores
        function generateGameSlides() {
            gameSlidesContainer.innerHTML = ''; // Limpiar slides existentes
            gameIndicator.innerHTML = ''; // Limpiar indicadores existentes

            games.forEach((game, index) => {
                // Crear el slide del juego
                const gameSlide = document.createElement('div');
                gameSlide.classList.add('game-slide');
                gameSlide.id = `slide-${game.id}`;
                gameSlide.style.top = `${index * 100}vh`; // Posiciona cada slide verticalmente

                // Contenido del slide
                gameSlide.innerHTML = `
                    <div class="game-content-wrapper">
                        <div class="game-info">
                            <h2 class="game-title">${game.name}</h2>
                            <p class="game-desc">${game.description}</p>
                            <p class="controls-info">Controles: ${game.controls}</p>
                            <div class="control-buttons">
                                <button class="control-btn play-btn" data-game-id="${game.id}">Jugar</button>
                            </div>
                        </div>
                        <div class="game-play-area" id="game-area-${game.id}">
                            ${game.gameContent}
                        </div>
                    </div>
                `;
                gameSlidesContainer.appendChild(gameSlide);

                // Crear el punto indicador
                const dot = document.createElement('div');
                dot.classList.add('indicator-dot');
                dot.setAttribute('data-slide-index', index);
                dot.addEventListener('click', () => {
                    showGame(index);
                });
                gameIndicator.appendChild(dot);
            });

            // Activar el primer juego y su indicador
            showGame(currentActiveGame);
        }

        // Muestra el juego especificado por su índice
        function showGame(index) {
            // Si ya hay una transición en curso, o el índice es el mismo, o está fuera de límites, no hacer nada.
            if (isGameTransitioning || index === currentActiveGame || index < 0 || index >= games.length) {
                return;
            }

            isGameTransitioning = true; // Bloquear nuevas transiciones

            currentActiveGame = index;
            // Desplaza el contenedor de slides verticalmente para mostrar el juego correcto
            const translateYValue = -index * 100;
            gameSlidesContainer.style.transform = `translateY(${translateYValue}vh)`;

            // Desactivar el juego anterior para liberar recursos
            // No hacemos esto inmediatamente sino que esperamos un pequeño tiempo para evitar glitches visuales
            // al cambiar el DOM mientras la animación CSS está activa.
            // Una forma más robusta sería detener el juego anterior antes de iniciar el nuevo.
            stopCurrentGame(); // Detener el juego actual ANTES de iniciar el nuevo

            // Actualizar puntos indicadores
            document.querySelectorAll('.indicator-dot').forEach((dot, idx) => {
                if (idx === index) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });

            // Iniciar o preparar el juego actual después de la transición
            gameSlidesContainer.addEventListener('transitionend', function handler() {
                gameSlidesContainer.removeEventListener('transitionend', handler);
                initializeGameSpecificContent(games[currentActiveGame].id);
                isGameTransitioning = false; // Desbloquear transiciones
            }, { once: true }); // El evento solo se dispara una vez
        }

        // Navegación con la rueda del ratón
        function handleScroll(event) {
            // No navegar si un modal está abierto o si la app principal no es visible
            if (isAuthModalOpen || appContainer.style.display !== 'flex' || isGameTransitioning) return;

            event.preventDefault(); // Evitar el scroll predeterminado de la página
            const delta = event.deltaY || event.detail || event.wheelDelta; // Detecta la dirección de la rueda

            if (delta > 0) { // Desplazarse hacia abajo (siguiente juego)
                showGame(currentActiveGame + 1);
            } else { // Desplazarse hacia arriba (juego anterior)
                showGame(currentActiveGame - 1);
            }
        }

        // Manejo de Swipe vertical para navegación en móviles (mismo que scroll)
        let touchStartY = 0;
        let touchEndY = 0;
        let touchStartX = 0;
        let touchEndX = 0;

        function handleTouchStart(event) {
            if (isAuthModalOpen || appContainer.style.display !== 'flex' || isGameTransitioning) return;
            touchStartY = event.touches[0].clientY;
            touchStartX = event.touches[0].clientX;
        }

        function handleTouchMove(event) {
            // Permitir el movimiento táctil, pero no navegar hasta el 'touchend'
            if (isAuthModalOpen || appContainer.style.display !== 'flex' || isGameTransitioning) return;
            touchEndY = event.touches[0].clientY;
            touchEndX = event.touches[0].clientX;
        }

        function handleTouchEnd() {
            if (isAuthModalOpen || appContainer.style.display !== 'flex' || isGameTransitioning) return;
            const swipeThreshold = 50; // Mínimo de píxeles para considerar un swipe

            const deltaY = touchStartY - touchEndY;
            const deltaX = touchStartX - touchEndX;

            // Determinar si es un swipe vertical dominante
            if (Math.abs(deltaY) > Math.abs(deltaX)) {
                if (deltaY > swipeThreshold) { // Swipe Up (siguiente juego)
                    showGame(currentActiveGame + 1);
                } else if (deltaY < -swipeThreshold) { // Swipe Down (juego anterior)
                    showGame(currentActiveGame - 1);
                }
            }
            // No hacemos nada para swipe horizontal, ya que la navegación es vertical.

            // Resetear valores para el siguiente swipe
            touchStartY = 0;
            touchEndY = 0;
            touchStartX = 0;
            touchEndX = 0;
        }

        // --- Funcionalidad de Autenticación (Login/Registro) ---

        startButton.addEventListener('click', () => {
            mainMenu.classList.add('hidden'); // Oculta el menú principal con animación
            setTimeout(() => {
                authModal.style.display = 'flex'; // Muestra el modal de login
                authModal.classList.add('show'); // Activa la animación del modal
                isAuthModalOpen = true;
            }, 500); // Esperar que termine la animación de ocultar el menú
        });

        closeAuthButton.addEventListener('click', () => {
            authModal.classList.remove('show'); // Desactiva la animación del modal
            setTimeout(() => {
                authModal.style.display = 'none'; // Oculta el modal de login
                mainMenu.classList.remove('hidden'); // Volver al menú principal
                isAuthModalOpen = false;
            }, 300); // Esperar que termine la animación de ocultar el modal
        });

        toggleAuthLink.addEventListener('click', (e) => {
            e.preventDefault(); // Evita que el enlace recargue la página
            if (authTitle.textContent === 'Iniciar Sesión') {
                authTitle.textContent = 'Registrarse';
                authSubmitButton.textContent = 'Registrarse';
                toggleAuthLink.textContent = 'Inicia Sesión aquí';
            } else {
                authTitle.textContent = 'Iniciar Sesión';
                authSubmitButton.textContent = 'Iniciar Sesión';
                toggleAuthLink.textContent = 'Regístrate aquí';
            }
        });

        authSubmitButton.addEventListener('click', () => {
            // Aquí iría la lógica real de autenticación (AJAX a un servidor, etc.)
            alert(`Simulando ${authTitle.textContent} para usuario: ${document.getElementById('username').value}`);
            authModal.classList.remove('show');
            setTimeout(() => {
                authModal.style.display = 'none';
                isAuthModalOpen = false;
                // Mostrar la interfaz principal de la app
                appContainer.style.display = 'flex';
                header.style.display = 'flex';
                updateGameControlsVisibility(); // Asegurarse de que los controles móviles se muestren si es necesario
                showGame(currentActiveGame); // Mostrar el primer juego o el actual
            }, 300);
        });

        // --- Funcionalidad de Botones Laterales (Likes, etc.) ---

        let likes = 0;
        let liked = false;
        likeButton.addEventListener('click', () => {
            if (!liked) {
                likes++;
                likeButton.querySelector('.side-icon').classList.add('liked');
                liked = true;
            } else {
                likes--;
                likeButton.querySelector('.side-icon').classList.remove('liked');
                liked = false;
            }
            likesCount.textContent = likes;
        });

        // --- Manejo de Controles de Juego (Teclado y Móviles) ---

        function updateGameControlsVisibility() {
            if (isMobile) {
                mobileControls.style.display = 'flex';
            } else {
                mobileControls.style.display = 'none';
            }
        }

        // Objeto global para almacenar funciones de control de juego
        // Cada juego al inicializarse, sobrescribirá estas funciones con las suyas.
        window.activeGameControls = {};
        // Objeto para rastrear qué teclas están actualmente presionadas, útil para movimiento continuo
        const pressedKeys = {};

        // Event listeners para controles móviles (D-pad y botones de acción)
        document.querySelectorAll('.mobile-btn').forEach(button => {
            button.addEventListener('pointerdown', (e) => {
                e.preventDefault(); // Evita el comportamiento predeterminado del navegador
                const control = button.getAttribute('data-control');
                console.log(`Control móvil presionado: ${control}`);
                // Llama a la función de control específica del juego activo
                if (window.activeGameControls && typeof window.activeGameControls[control] === 'function') {
                    window.activeGameControls[control]();
                }
            });
            // Puedes agregar 'pointerup' si necesitas detectar cuándo se suelta el botón móvil
            button.addEventListener('pointerup', (e) => {
                const control = button.getAttribute('data-control');
                // Si el control es de movimiento y el juego tiene una función stopMove
                if ((control === 'left' || control === 'right' || control === 'up' || control === 'down') && window.activeGameControls && typeof window.activeGameControls.stopMove === 'function') {
                    window.activeGameControls.stopMove(control); // Pasa qué dirección se soltó
                }
            });
        });


        // Event listener para teclado (ASWD para juego, FLECHAS para navegación)
        document.addEventListener('keydown', (e) => {
            // No procesar si un modal está abierto o la app principal no es visible
            if (isAuthModalOpen || appContainer.style.display !== 'flex' || isGameTransitioning) return;

            let controlAction = null;

            switch (e.key.toLowerCase()) {
                case 'arrowup': // Navegación de juego
                    e.preventDefault();
                    showGame(currentActiveGame - 1);
                    return; // No pasar a los controles del juego
                case 'arrowdown': // Navegación de juego
                    e.preventDefault();
                    showGame(currentActiveGame + 1);
                    return; // No pasar a los controles del juego
                case 'arrowleft': // Navegación de juego
                    e.preventDefault();
                    showGame(currentActiveGame - 1);
                    return; // No pasar a los controles del juego
                case 'arrowright': // Navegación de juego
                    e.preventDefault();
                    showGame(currentActiveGame + 1);
                    return; // No pasar a los controles del juego
                case 'w':
                    controlAction = 'up';
                    break;
                case 's':
                    controlAction = 'down';
                    break;
                case 'a':
                    controlAction = 'left';
                    break;
                case 'd':
                    controlAction = 'right';
                    break;
                case ' ': // Espacio para acción o salto
                    controlAction = 'action1';
                    break;
                case 'enter': // Enter para iniciar/pausar o una segunda acción
                    controlAction = 'action2';
                    break;
            }

            // Si se detecta una acción de control de juego y la tecla no está ya registrada como presionada
            if (controlAction && window.activeGameControls && typeof window.activeGameControls[controlAction] === 'function' && !pressedKeys[controlAction]) {
                e.preventDefault(); // Evita el scroll u otras acciones predeterminadas del navegador
                window.activeGameControls[controlAction](); // Ejecuta la función de control del juego
                pressedKeys[controlAction] = true; // Marca la tecla como presionada
            }
        });

        // Event listener para soltar teclas (importante para detener movimiento continuo)
        document.addEventListener('keyup', (e) => {
            if (isAuthModalOpen || appContainer.style.display !== 'flex' || isGameTransitioning) return;

            let controlAction = null;
            switch (e.key.toLowerCase()) {
                case 'a':
                    controlAction = 'left';
                    break;
                case 'd':
                    controlAction = 'right';
                    break;
                case 'w':
                    controlAction = 'up';
                    break;
                case 's':
                    controlAction = 'down';
                    break;
            }

            if (controlAction) {
                // Si la acción es de movimiento y el juego tiene una función para detenerlo
                if (window.activeGameControls && typeof window.activeGameControls.stopMove === 'function') {
                    window.activeGameControls.stopMove(controlAction);
                }
                delete pressedKeys[controlAction]; // Desmarca la tecla como presionada
            }
        });

        // --- Detener y Reiniciar Juegos ---
        function stopCurrentGame() {
            // Llama a una función de "detener" o "limpiar" si el juego activo la tiene
            if (window.activeGameControls && typeof window.activeGameControls.stopGame === 'function') {
                window.activeGameControls.stopGame();
            }

            // Limpiar todos los intervalos globales de juegos
            if (snakeGameInterval) { clearInterval(snakeGameInterval); snakeGameInterval = null; }
            if (pongGameInterval) { clearInterval(pongGameInterval); pongGameInterval = null; }
            if (flappyGameInterval) { clearInterval(flappyGameInterval); flappyGameInterval = null; }
            if (breakoutGameInterval) { clearInterval(breakoutGameInterval); breakoutGameInterval = null; }

            // Restablecer el objeto de controles activos
            window.activeGameControls = {};
        }

        // --- Inicialización de Contenido Específico de Juegos ---
        function initializeGameSpecificContent(gameId) {
            // Asegúrate de que el juego anterior se ha detenido.
            // Esto es crucial si los juegos comparten recursos o usan intervalos.
            // Ya se llamó a stopCurrentGame antes de la transición en showGame().

            // Aquí se ejecutarán funciones específicas para cada juego,
            // que se encargarán de inicializar su lógica y elementos del DOM.
            switch (gameId) {
                case 'game1': // Memoria
                    console.log('Inicializando juego de Memoria...');
                    initializeMemoryGame();
                    break;
                case 'game2': // Serpiente
                    console.log('Inicializando juego de Serpiente...');
                    initializeSnakeGame();
                    break;
                case 'game3': // Pong
                    console.log('Inicializando juego de Pong...');
                    initializePongGame();
                    break;
                case 'game4': // Flappy Bird
                    console.log('Inicializando juego de Flappy Bird...');
                    initializeFlappyBirdGame();
                    break;
                case 'game5': // Breakout
                    console.log('Inicializando juego de Breakout...');
                    initializeBreakoutGame();
                    break;
                default:
                    console.log('Juego no reconocido o sin lógica de inicialización específica.');
            }
        }

        // --- Lógica de Juegos Individuales (Esqueletos Funcionales) ---

        // Game 1: Memoria
        function initializeMemoryGame() {
            const memoryGameDiv = document.querySelector(`#game-area-game1 .memory-game`);
            if (!memoryGameDiv) return;

            memoryGameDiv.innerHTML = ''; // Limpiar cualquier juego anterior
            const icons = ['⭐', '🍄', '👻', '💎', '🚀', '🌈', '⚡', '🤖'];
            let cards = [...icons, ...icons]; // Duplicar para parejas
            cards.sort(() => Math.random() - 0.5); // Mezclar aleatoriamente

            let flippedCards = [];
            let matchedCards = [];
            let canFlip = true; // Para evitar que el usuario voltee más de 2 cartas

            cards.forEach((icon, index) => {
                const card = document.createElement('div');
                card.classList.add('memory-card');
                card.innerHTML = `<div class="front">?</div><div class="back">${icon}</div>`;
                card.dataset.index = index;
                card.dataset.value = icon;
                card.addEventListener('click', () => flipCard(card));
                memoryGameDiv.appendChild(card);
            });

            function flipCard(card) {
                if (!canFlip || flippedCards.length >= 2 || card.classList.contains('flipped') || card.classList.contains('matched')) {
                    return; // No permitir voltear si ya hay dos volteadas, no se puede voltear, o ya está volteada/emparejada
                }

                card.classList.add('flipped');
                flippedCards.push(card);

                if (flippedCards.length === 2) {
                    canFlip = false; // Bloquear más volteos
                    setTimeout(checkForMatch, 1000); // Esperar 1 segundo antes de comprobar
                }
            }

            function checkForMatch() {
                const [card1, card2] = flippedCards;
                if (card1.dataset.value === card2.dataset.value) {
                    card1.classList.add('matched');
                    card2.classList.add('matched');
                    matchedCards.push(card1, card2);
                    if (matchedCards.length === cards.length) {
                        alert('¡Felicidades, encontraste todas las parejas!');
                        // Opcional: Reiniciar el juego automáticamente
                        // initializeMemoryGame();
                    }
                } else {
                    card1.classList.remove('flipped');
                    card2.classList.remove('flipped');
                }
                flippedCards = [];
                canFlip = true; // Permitir voltear de nuevo
            }

            // Exponer un control para reiniciar el juego, por ejemplo.
            window.activeGameControls = {
                action2: () => { // Botón de Reiniciar
                    console.log('Reiniciando juego de Memoria...');
                    initializeMemoryGame();
                },
                stopGame: () => {
                    // No hay intervalos que limpiar en el juego de memoria
                    console.log('Juego de Memoria detenido/limpiado.');
                }
            };
        }


        // Game 2: Serpiente
        let snakeGameInterval = null; // Para almacenar la instancia del juego
        let snakeGameStarted = false; // Para saber si el juego está en marcha

        function initializeSnakeGame() {
            const canvas = document.getElementById('snake-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const gridSize = 15; // Tamaño de cada segmento de la serpiente
            const tileCount = canvas.width / gridSize; // Número de celdas en el tablero

            let snake = [{ x: 10, y: 10 }]; // Posición inicial de la serpiente
            let food = {};
            let dx = 0; // Dirección horizontal (1: derecha, -1: izquierda)
            let dy = 0; // Dirección vertical (1: abajo, -1: arriba)
            let score = 0;
            let gamePaused = true; // Empieza pausado
            let changingDirection = false; // Para evitar giros dobles rápidos

            // Asegurarse de que el intervalo anterior se limpia si existía
            if (snakeGameInterval) clearInterval(snakeGameInterval);
            snakeGameInterval = null;
            snakeGameStarted = false; // Reiniciar el estado de inicio

            function generateFood() {
                food = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
                // Asegurarse de que la comida no aparezca en la serpiente
                for (let i = 0; i < snake.length; i++) {
                    if (food.x === snake[i].x && food.y === snake[i].y) {
                        generateFood(); // Regenerar si la comida está en la serpiente
                        return; // Salir para evitar bucle infinito si el tablero está lleno
                    }
                }
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpiar el canvas
                ctx.fillStyle = '#333'; // Fondo del canvas
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Dibujar comida
                ctx.fillStyle = 'red';
                ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize, gridSize);

                // Dibujar serpiente
                ctx.fillStyle = 'lime';
                snake.forEach(segment => {
                    ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
                    ctx.strokeStyle = '#006600'; // Borde oscuro
                    ctx.strokeRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
                });
            }

            function moveSnake() {
                if (gamePaused) return;

                const head = { x: snake[0].x + dx, y: snake[0].y + dy };

                if (gameOver(head)) {
                    clearInterval(snakeGameInterval);
                    snakeGameInterval = null;
                    snakeGameStarted = false;
                    alert(`¡Juego Terminado! Puntuación: ${score}`);
                    return;
                }

                snake.unshift(head); // Añadir nueva cabeza

                // Si come la comida
                if (head.x === food.x && head.y === food.y) {
                    score++;
                    generateFood(); // Generar nueva comida
                } else {
                    snake.pop(); // Quitar la cola
                }
                changingDirection = false; // Permitir cambiar de dirección de nuevo
                draw();
            }

            function gameOver(head) {
                // Chocar con la pared
                const hitLeftWall = head.x < 0;
                const hitRightWall = head.x >= tileCount;
                const hitTopWall = head.y < 0;
                const hitBottomWall = head.y >= tileCount;

                if (hitLeftWall || hitRightWall || hitTopWall || hitBottomWall) return true;

                // Chocar con el propio cuerpo (empezar a comprobar desde el 4º segmento)
                for (let i = 4; i < snake.length; i++) {
                    if (head.x === snake[i].x && head.y === snake[i].y) return true;
                }
                return false;
            }

            function changeDirection(newDx, newDy) {
                if (changingDirection || (dx === -newDx && newDx !== 0) || (dy === -newDy && newDy !== 0)) {
                    // Evitar giros múltiples en un mismo frame o giro de 180 grados
                    return;
                }
                changingDirection = true;
                dx = newDx;
                dy = newDy;
                if (!snakeGameStarted) { // Iniciar el juego al primer movimiento
                    snakeGameStarted = true;
                    gamePaused = false;
                    snakeGameInterval = setInterval(moveSnake, 100);
                }
            }

            function togglePause() {
                if (!snakeGameStarted) { // Si el juego no ha empezado, el primer toggle lo inicia
                    snakeGameStarted = true;
                    gamePaused = false;
                    snakeGameInterval = setInterval(moveSnake, 100);
                    console.log('Juego de Serpiente iniciado.');
                } else {
                    gamePaused = !gamePaused;
                    if (!gamePaused) {
                        snakeGameInterval = setInterval(moveSnake, 100);
                        console.log('Juego de Serpiente reanudado');
                    } else {
                        clearInterval(snakeGameInterval);
                        snakeGameInterval = null;
                        console.log('Juego de Serpiente pausado');
                    }
                }
            }

            function resetSnakeGame() {
                clearInterval(snakeGameInterval);
                snakeGameInterval = null;
                snakeGameStarted = false;
                snake = [{ x: 10, y: 10 }];
                dx = 0; dy = 0; score = 0;
                gamePaused = true; // Reiniciar en estado pausado
                generateFood();
                draw();
                console.log('Juego de Serpiente reiniciado (en pausa). Presiona A/S/W/D para iniciar.');
            }

            // Exponer controles al objeto global
            window.activeGameControls = {
                up: () => changeDirection(0, -1),
                down: () => changeDirection(0, 1),
                left: () => changeDirection(-1, 0),
                right: () => changeDirection(1, 0),
                action1: togglePause, // Botón de acción para pausar/reanudar
                action2: resetSnakeGame, // Botón de acción para reiniciar
                stopGame: () => {
                    clearInterval(snakeGameInterval);
                    snakeGameInterval = null;
                    snakeGameStarted = false;
                    console.log('Juego de Serpiente detenido/limpiado.');
                }
            };

            // Inicializar solo el dibujo y la comida, sin iniciar el movimiento
            generateFood();
            draw();
            console.log('Juego de Serpiente listo. Presiona A/S/W/D o acción 1 para empezar.');
        }

        // Game 3: Pong
        let pongGameInterval = null;
        let leftPaddleY;
        let rightPaddleY;
        let ballX;
        let ballY;
        let ballDx; // Velocidad de la pelota en X
        let ballDy; // Velocidad de la pelota en Y
        let leftScore;
        let rightScore;
        const paddleSpeed = 8; // Velocidad de las paletas
        let pongGamePaused = true; // Empieza pausado
        let pongGameDiv; // Declarar aquí para que sea accesible en resetPongGame
        let leftPaddleMovement = 0; // -1 for up, 1 for down, 0 for stop

        function initializePongGame() {
            pongGameDiv = document.getElementById('pong-game');
            if (!pongGameDiv) return;

            const leftPaddle = document.getElementById('left-paddle');
            const rightPaddle = document.getElementById('right-paddle');
            const ball = document.querySelector('.ball');
            const leftScoreElem = document.getElementById('left-score');
            const rightScoreElem = document.getElementById('right-score');

            // Asegurarse de que el intervalo anterior se limpia si existía
            if (pongGameInterval) clearInterval(pongGameInterval);
            pongGameInterval = null; // Reiniciar

            // Resetear estado
            leftPaddleY = pongGameDiv.offsetHeight / 2 - leftPaddle.offsetHeight / 2;
            rightPaddleY = pongGameDiv.offsetHeight / 2 - rightPaddle.offsetHeight / 2;
            leftPaddle.style.top = `${leftPaddleY}px`;
            rightPaddle.style.top = `${rightPaddleY}px`;
            resetBall(); // Inicializa la posición y dirección de la pelota
            leftScore = 0; rightScore = 0;
            leftScoreElem.textContent = leftScore;
            rightScoreElem.textContent = rightScore;
            pongGamePaused = true; // Siempre inicia pausado
            leftPaddleMovement = 0; // Detener movimiento inicial

            function updatePongGame() {
                if (pongGamePaused) return;

                // Mover paleta izquierda por el jugador
                leftPaddleY += leftPaddleMovement * paddleSpeed;

                // Mover paleta derecha (IA básica)
                if (ballY > rightPaddleY + rightPaddle.offsetHeight / 2) {
                    rightPaddleY += Math.min(paddleSpeed, ballY - (rightPaddleY + rightPaddle.offsetHeight / 2));
                } else if (ballY < rightPaddleY + rightPaddle.offsetHeight / 2) {
                    rightPaddleY -= Math.min(paddleSpeed, (rightPaddleY + rightPaddle.offsetHeight / 2) - ballY);
                }

                // Limitar paletas a los bordes
                leftPaddleY = Math.max(0, Math.min(pongGameDiv.offsetHeight - leftPaddle.offsetHeight, leftPaddleY));
                rightPaddleY = Math.max(0, Math.min(pongGameDiv.offsetHeight - rightPaddle.offsetHeight, rightPaddleY));

                leftPaddle.style.top = `${leftPaddleY}px`;
                rightPaddle.style.top = `${rightPaddleY}px`;

                // Mover pelota
                ballX += ballDx;
                ballY += ballDy;

                // Rebote en paredes superior/inferior
                if (ballY <= 0 || ballY >= pongGameDiv.offsetHeight - ball.offsetHeight) {
                    ballDy *= -1;
                }

                // Rebote en paletas
                // Paleta izquierda
                if (ballDx < 0 && // Solo si la pelota se mueve hacia la izquierda
                    ballX <= leftPaddle.offsetLeft + leftPaddle.offsetWidth &&
                    ballY + ball.offsetHeight >= leftPaddleY &&
                    ballY <= leftPaddleY + leftPaddle.offsetHeight) {
                    ballDx *= -1;
                    ballX = leftPaddle.offsetLeft + leftPaddle.offsetWidth; // Ajustar posición para evitar que se pegue
                }
                // Paleta derecha
                if (ballDx > 0 && // Solo si la pelota se mueve hacia la derecha
                    ballX + ball.offsetWidth >= rightPaddle.offsetLeft &&
                    ballY + ball.offsetHeight >= rightPaddleY &&
                    ballY <= rightPaddleY + rightPaddle.offsetHeight) {
                    ballDx *= -1;
                    ballX = rightPaddle.offsetLeft - ball.offsetWidth; // Ajustar posición
                }

                // Anotar puntos
                if (ballX < 0) {
                    rightScore++;
                    rightScoreElem.textContent = rightScore;
                    if (rightScore >= 7) { gameOverPong('¡Perdiste!'); return; }
                    resetBall();
                } else if (ballX > pongGameDiv.offsetWidth - ball.offsetWidth) {
                    leftScore++;
                    leftScoreElem.textContent = leftScore;
                    if (leftScore >= 7) { gameOverPong('¡Ganaste!'); return; }
                    resetBall();
                }

                ball.style.left = `${ballX}px`;
                ball.style.top = `${ballY}px`;
            }

            function resetBall() {
                ballX = pongGameDiv.offsetWidth / 2 - ball.offsetWidth / 2;
                ballY = pongGameDiv.offsetHeight / 2 - ball.offsetHeight / 2;
                // Direcciones iniciales de la pelota, aleatorias pero con velocidad mínima
                ballDx = (Math.random() > 0.5 ? 1 : -1) * (5 + Math.random() * 2);
                ballDy = (Math.random() > 0.5 ? 1 : -1) * (5 + Math.random() * 2);
            }

            function gameOverPong(message) {
                clearInterval(pongGameInterval);
                pongGameInterval = null;
                pongGamePaused = true;
                alert(`¡Fin del juego! ${message}`);
            }

            function togglePongPause() {
                pongGamePaused = !pongGamePaused;
                if (!pongGamePaused) {
                    pongGameInterval = setInterval(updatePongGame, 1000 / 60); // 60 FPS
                    console.log('Juego de Pong reanudado');
                } else {
                    clearInterval(pongGameInterval);
                    pongGameInterval = null;
                    console.log('Juego de Pong pausado');
                }
            }

            function resetPongGame() {
                clearInterval(pongGameInterval);
                pongGameInterval = null;
                initializePongGame(); // Re-inicializar todo el juego
                // No iniciar el intervalo aquí, se iniciará con togglePongPause()
                console.log('Juego de Pong reiniciado (en pausa).');
            }

            // Exponer controles
            window.activeGameControls = {
                up: () => { if (!pongGamePaused) leftPaddleMovement = -1; },
                down: () => { if (!pongGamePaused) leftPaddleMovement = 1; },
                w: () => { if (!pongGamePaused) leftPaddleMovement = -1; },
                s: () => { if (!pongGamePaused) leftPaddleMovement = 1; },
                stopMove: (direction) => {
                    if ((direction === 'up' || direction === 'w') && leftPaddleMovement === -1) {
                        leftPaddleMovement = 0;
                    }
                    if ((direction === 'down' || direction === 's') && leftPaddleMovement === 1) {
                        leftPaddleMovement = 0;
                    }
                },
                action1: togglePongPause, // Iniciar/Pausar
                action2: resetPongGame, // Reiniciar
                stopGame: () => {
                    clearInterval(pongGameInterval);
                    pongGameInterval = null;
                    pongGamePaused = true;
                    console.log('Juego de Pong detenido/limpiado.');
                }
            };
            // No iniciar el intervalo aquí, se iniciará con togglePongPause()
        }

        // Game 4: Flappy Bird
        let flappyGameInterval = null;
        let flappyBirdGameStarted = false;
        let birdY;
        let birdVelocity;
        let pipes;
        let flappyScore;
        let gameAreaFlappy; // Para referencia global

        function initializeFlappyBirdGame() {
            gameAreaFlappy = document.getElementById('flappy-game');
            const bird = document.getElementById('bird');
            if (!gameAreaFlappy || !bird) return;

            // Asegurarse de que el intervalo anterior se limpia si existía
            if (flappyGameInterval) clearInterval(flappyGameInterval);
            flappyGameInterval = null;

            // Restablecer posiciones y estados iniciales
            birdY = 200;
            birdVelocity = 0;
            const gravity = 0.5;
            const flapStrength = -8;
            pipes = [];
            flappyScore = 0;
            flappyBirdGameStarted = false; // El juego empieza al primer aleteo

            bird.style.top = `${birdY}px`; // Aplicar la posición inicial
            bird.style.left = '50px';

            // Limpiar tuberías previas
            gameAreaFlappy.querySelectorAll('.pipe').forEach(p => p.remove());

            function createPipe() {
                const minPipeHeight = 50; // Altura mínima de la tubería
                const maxPipeHeight = gameAreaFlappy.offsetHeight / 2 - 50; // Altura máxima
                const pipeHeight = Math.floor(Math.random() * (maxPipeHeight - minPipeHeight + 1)) + minPipeHeight;
                const gap = 120; // Tamaño del hueco entre tuberías

                const topPipe = document.createElement('div');
                topPipe.classList.add('pipe', 'top');
                topPipe.style.height = `${pipeHeight}px`;
                topPipe.style.left = `${gameAreaFlappy.offsetWidth}px`;

                const bottomPipe = document.createElement('div');
                bottomPipe.classList.add('pipe', 'bottom');
                bottomPipe.style.height = `${gameAreaFlappy.offsetHeight - pipeHeight - gap}px`;
                bottomPipe.style.left = `${gameAreaFlappy.offsetWidth}px`;

                gameAreaFlappy.appendChild(topPipe);
                gameAreaFlappy.appendChild(bottomPipe);

                pipes.push({ top: topPipe, bottom: bottomPipe, passed: false });
            }

            function updateFlappyBirdGame() {
                if (!flappyBirdGameStarted) return; // No actualizar si no ha comenzado

                birdVelocity += gravity;
                birdY += birdVelocity;
                bird.style.top = `${birdY}px`;

                // Game Over si golpea el suelo o el techo
                if (birdY <= 0 || birdY >= gameAreaFlappy.offsetHeight - bird.offsetHeight) {
                    gameOverFlappy();
                    return;
                }

                // Mover y crear tuberías
                pipes.forEach(pipePair => {
                    pipePair.top.style.left = `${pipePair.top.offsetLeft - 3}px`;
                    pipePair.bottom.style.left = `${pipePair.bottom.offsetLeft - 3}px`;

                    // Eliminar tuberías fuera de pantalla
                    if (pipePair.top.offsetLeft + pipePair.top.offsetWidth < 0) {
                        pipePair.top.remove();
                        pipePair.bottom.remove();
                        pipes = pipes.filter(p => p !== pipePair); // Remover del array
                    }

                    // Detección de colisión con tuberías
                    const birdRect = bird.getBoundingClientRect();
                    const topPipeRect = pipePair.top.getBoundingClientRect();
                    const bottomPipeRect = pipePair.bottom.getBoundingClientRect();

                    // Comprobar colisión con tubería superior
                    if (birdRect.left < topPipeRect.right && birdRect.right > topPipeRect.left &&
                        birdRect.top < topPipeRect.bottom && birdRect.bottom > topPipeRect.top) {
                        gameOverFlappy();
                        return;
                    }
                    // Comprobar colisión con tubería inferior
                    if (birdRect.left < bottomPipeRect.right && birdRect.right > bottomPipeRect.left &&
                        birdRect.top < bottomPipeRect.bottom && birdRect.bottom > bottomPipeRect.top) {
                        gameOverFlappy();
                        return;
                    }

                    // Aumentar puntuación
                    if (!pipePair.passed && bird.offsetLeft > pipePair.top.offsetLeft + pipePair.top.offsetWidth) {
                        flappyScore++;
                        console.log('Flappy Score:', flappyScore);
                        pipePair.passed = true;
                    }
                });

                // Crear nuevas tuberías (cuando la última tubería visible está a una distancia adecuada)
                if (pipes.length === 0 || (pipes.length > 0 && pipes[pipes.length - 1].top.offsetLeft < gameAreaFlappy.offsetWidth - 200)) {
                    createPipe();
                }
            }

            function flap() {
                if (!flappyBirdGameStarted) {
                    flappyBirdGameStarted = true;
                    flappyGameInterval = setInterval(updateFlappyBirdGame, 1000 / 60); // 60 FPS
                    createPipe(); // La primera tubería se crea al iniciar el juego
                }
                birdVelocity = flapStrength;
            }

            function gameOverFlappy() {
                clearInterval(flappyGameInterval);
                flappyGameInterval = null;
                flappyBirdGameStarted = false;
                alert(`¡Flappy Bird! Puntuación: ${flappyScore}. Presiona "Jugar" o "Acción 2" para reiniciar.`);
            }

            // Exponer controles
            window.activeGameControls = {
                action1: flap, // Espacio o botón de acción para aletear
                action2: () => { // Reiniciar
                    initializeFlappyBirdGame();
                },
                stopGame: () => {
                    clearInterval(flappyGameInterval);
                    flappyGameInterval = null;
                    flappyBirdGameStarted = false;
                    console.log('Juego de Flappy Bird detenido/limpiado.');
                }
            };

            // Evento de clic en el área de juego para aletear
            gameAreaFlappy.onclick = () => {
                flap(); // Siempre aletear al click
            };
        }

        // Game 5: Breakout
        let breakoutGameInterval = null; // Para el intervalo de juego
        let breakoutCanvas, breakoutCtx;
        let breakoutPaddle, breakoutBall, breakoutBricks;
        let breakoutScore, breakoutLives;
        let breakoutGameActive = false; // Para controlar si el juego está en marcha
        const brickConfig = {
            rowCount: 5,
            columnCount: 8,
            width: 40,
            height: 15,
            padding: 5,
            offsetTop: 30,
            offsetLeft: 30
        };

        function initializeBreakoutGame() {
            breakoutCanvas = document.getElementById('breakout-canvas');
            if (!breakoutCanvas) return;
            breakoutCtx = breakoutCanvas.getContext('2d');

            // Asegurarse de que el intervalo anterior se limpia si existía
            if (breakoutGameInterval) clearInterval(breakoutGameInterval);
            breakoutGameInterval = null;

            breakoutPaddle = {
                x: breakoutCanvas.width / 2 - 40,
                y: breakoutCanvas.height - 20,
                width: 80,
                height: 10,
                dx: 0, // Movimiento horizontal actual
                speed: 7
            };

            breakoutBall = {
                x: breakoutCanvas.width / 2,
                y: breakoutPaddle.y - 10,
                radius: 7,
                dx: 0, // Inicia quieta hasta que se pulsa Jugar/Accion1
                dy: 0
            };

            breakoutBricks = [];
            breakoutScore = 0;
            breakoutLives = 3;
            breakoutGameActive = false; // El juego empieza al primer 'action1' o 'play-btn'

            createBreakoutBricks(); // Generar los ladrillos inicialmente
            drawBreakoutGame(); // Dibujar el estado inicial

            // Exponer controles
            window.activeGameControls = {
                left: () => { if (breakoutGameActive) breakoutPaddle.dx = -breakoutPaddle.speed; },
                right: () => { if (breakoutGameActive) breakoutPaddle.dx = breakoutPaddle.speed; },
                a: () => { if (breakoutGameActive) breakoutPaddle.dx = -breakoutPaddle.speed; },
                d: () => { if (breakoutGameActive) breakoutPaddle.dx = breakoutPaddle.speed; },
                stopMove: () => { breakoutPaddle.dx = 0; }, // Detiene el movimiento
                action1: toggleBreakoutGame, // Iniciar/Pausar
                action2: resetBreakoutGame, // Reiniciar
                stopGame: () => {
                    clearInterval(breakoutGameInterval);
                    breakoutGameInterval = null;
                    breakoutGameActive = false;
                    console.log('Juego de Breakout detenido/limpiado.');
                }
            };
        }

        function createBreakoutBricks() {
            breakoutBricks = [];
            for (let c = 0; c < brickConfig.columnCount; c++) {
                breakoutBricks[c] = [];
                for (let r = 0; r < brickConfig.rowCount; r++) {
                    breakoutBricks[c][r] = { x: 0, y: 0, status: 1 }; // Status 1 = visible
                }
            }
        }

        function drawPaddle() {
            breakoutCtx.fillStyle = '#fff';
            breakoutCtx.fillRect(breakoutPaddle.x, breakoutPaddle.y, breakoutPaddle.width, breakoutPaddle.height);
        }

        function drawBall() {
            breakoutCtx.beginPath();
            breakoutCtx.arc(breakoutBall.x, breakoutBall.y, breakoutBall.radius, 0, Math.PI * 2);
            breakoutCtx.fillStyle = '#ff0050';
            breakoutCtx.fill();
            breakoutCtx.closePath();
        }

        function drawBricks() {
            for (let c = 0; c < brickConfig.columnCount; c++) {
                for (let r = 0; r < brickConfig.rowCount; r++) {
                    if (breakoutBricks[c][r].status === 1) {
                        const brickX = (c * (brickConfig.width + brickConfig.padding)) + brickConfig.offsetLeft;
                        const brickY = (r * (brickConfig.height + brickConfig.padding)) + brickConfig.offsetTop;
                        breakoutBricks[c][r].x = brickX;
                        breakoutBricks[c][r].y = brickY;
                        breakoutCtx.fillStyle = '#00ffaa'; // Color de los ladrillos
                        breakoutCtx.fillRect(brickX, brickY, brickConfig.width, brickConfig.height);
                    }
                }
            }
        }

        function collisionDetection() {
            for (let c = 0; c < brickConfig.columnCount; c++) {
                for (let r = 0; r < brickConfig.rowCount; r++) {
                    const b = breakoutBricks[c][r];
                    if (b.status === 1) {
                        // Simple AABB collision detection
                        if (breakoutBall.x + breakoutBall.radius > b.x && breakoutBall.x - breakoutBall.radius < b.x + brickConfig.width &&
                            breakoutBall.y + breakoutBall.radius > b.y && breakoutBall.y - breakoutBall.radius < b.y + brickConfig.height) {
                            breakoutBall.dy *= -1; // Invertir dirección vertical
                            b.status = 0; // Marcar ladrillo como destruido
                            breakoutScore++;
                            if (breakoutScore === brickConfig.rowCount * brickConfig.columnCount) {
                                gameOverBreakout("¡GANASTE, FELICIDADES!");
                                return;
                            }
                        }
                    }
                }
            }
        }

        function drawScore() {
            breakoutCtx.font = "16px Arial";
            breakoutCtx.fillStyle = "#fff";
            breakoutCtx.fillText(`Puntos: ${breakoutScore}`, 8, 20);
        }

        function drawLives() {
            breakoutCtx.font = "16px Arial";
            breakoutCtx.fillStyle = "#fff";
            breakoutCtx.fillText(`Vidas: ${breakoutLives}`, breakoutCanvas.width - 75, 20);
        }

        function drawBreakoutGame() {
            breakoutCtx.clearRect(0, 0, breakoutCanvas.width, breakoutCanvas.height); // Limpiar el canvas
            breakoutCtx.fillStyle = '#333'; // Fondo del canvas de Breakout
            breakoutCtx.fillRect(0, 0, breakoutCanvas.width, breakoutCanvas.height);

            drawBricks();
            drawPaddle();
            drawBall();
            drawScore();
            drawLives();
        }

        function updateBreakoutGame() {
            if (!breakoutGameActive) return; // No actualizar si no está activo

            collisionDetection();

            breakoutBall.x += breakoutBall.dx;
            breakoutBall.y += breakoutBall.dy;

            // Rebote en paredes laterales
            if (breakoutBall.x + breakoutBall.radius > breakoutCanvas.width || breakoutBall.x - breakoutBall.radius < 0) {
                breakoutBall.dx *= -1;
            }
            // Rebote en pared superior
            if (breakoutBall.y - breakoutBall.radius < 0) {
                breakoutBall.dy *= -1;
            }

            // Rebote en paleta
            // Asegurarse de que la pelota esté en la altura de la paleta y dentro del ancho
            if (breakoutBall.y + breakoutBall.radius >= breakoutPaddle.y &&
                breakoutBall.y + breakoutBall.radius <= breakoutPaddle.y + breakoutPaddle.height && // Para evitar doble rebote si la pelota atraviesa
                breakoutBall.x > breakoutPaddle.x &&
                breakoutBall.x < breakoutPaddle.x + breakoutPaddle.width) {

                if (breakoutBall.dy > 0) { // Solo si la pelota se mueve hacia abajo
                    breakoutBall.dy *= -1;
                }
            }

            // Pelota cae al fondo
            if (breakoutBall.y + breakoutBall.radius > breakoutCanvas.height) {
                breakoutLives--;
                if (breakoutLives === 0) {
                    gameOverBreakout("¡FIN DEL JUEGO!");
                } else {
                    // Reiniciar posición de la pelota y paleta
                    breakoutBall.x = breakoutCanvas.width / 2;
                    breakoutBall.y = breakoutPaddle.y - 10;
                    breakoutBall.dx = 4 * (Math.random() > 0.5 ? 1 : -1);
                    breakoutBall.dy = -4; // Siempre hacia arriba
                    breakoutPaddle.x = breakoutCanvas.width / 2 - 40;
                }
            }

            // Mover paleta
            breakoutPaddle.x += breakoutPaddle.dx;
            if (breakoutPaddle.x < 0) breakoutPaddle.x = 0;
            if (breakoutPaddle.x + breakoutPaddle.width > breakoutCanvas.width) {
                breakoutPaddle.x = breakoutCanvas.width - breakoutPaddle.width;
            }
            drawBreakoutGame();
        }

        function toggleBreakoutGame() {
            if (!breakoutGameActive) { // Si el juego no está activo, iniciarlo
                breakoutGameActive = true;
                // Si la pelota está quieta, dale un empujón inicial
                if (breakoutBall.dx === 0 && breakoutBall.dy === 0) {
                    breakoutBall.dx = 4 * (Math.random() > 0.5 ? 1 : -1);
                    breakoutBall.dy = -4;
                }
                breakoutGameInterval = setInterval(updateBreakoutGame, 1000 / 60); // 60 FPS
                console.log('Juego de Breakout iniciado/reanudado.');
            } else { // Si está activo, pausarlo
                breakoutGameActive = false;
                clearInterval(breakoutGameInterval);
                breakoutGameInterval = null;
                console.log('Juego de Breakout pausado.');
            }
        }

        function resetBreakoutGame() {
            clearInterval(breakoutGameInterval);
            breakoutGameInterval = null;
            initializeBreakoutGame(); // Reinicializa todos los valores
            // No iniciar el intervalo aquí, se iniciará con toggleBreakoutGame()
            console.log('Juego de Breakout reiniciado (en pausa).');
        }

        function gameOverBreakout(message) {
            clearInterval(breakoutGameInterval);
            breakoutGameInterval = null;
            breakoutGameActive = false;
            alert(message);
        }


        // --- Utilidades ---

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        // Actualizar el estado móvil al cambiar el tamaño de la ventana
        window.addEventListener('resize', () => {
            isMobile = window.innerWidth <= 768;
            updateGameControlsVisibility();
            // Si tus juegos tienen tamaños de canvas dinámicos, aquí podrías redibujarlos.
            // Para juegos basados en CSS como Pong, Flappy, solo se ajustará por CSS.
        });

        // Inicializar al cargar la página
        document.addEventListener('DOMContentLoaded', () => {
            generateCarouselItems();
            generateGameSlides(); // Generar los slides y sus indicadores
            updateGameControlsVisibility(); // Establecer la visibilidad inicial de los controles móviles

            // Asegurar que los elementos estén en el estado inicial correcto
            mainMenu.classList.remove('hidden');
            appContainer.style.display = 'none';
            header.style.display = 'none';
            authModal.style.display = 'none';
        });

        // Añadir eventos de scroll para la navegación entre juegos
        document.body.addEventListener('wheel', handleScroll, { passive: false });

        // Añadir eventos de touch para navegación en móviles (SWIPE VERTICAL entre juegos)
        document.body.addEventListener('touchstart', handleTouchStart, { passive: true });
        document.body.addEventListener('touchmove', handleTouchMove, { passive: true });
        document.body.addEventListener('touchend', handleTouchEnd);

        // Asignar eventos a los botones "Jugar" (después de que los slides existan en el DOM)
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('play-btn')) {
                const gameId = e.target.getAttribute('data-game-id');
                console.log(`Presionaste Jugar para: ${gameId}`);
                // Llamar a la acción principal del juego para iniciarlo, si existe.
                // Esto simula presionar el botón de acción 1 o la tecla de espacio.
                if (window.activeGameControls && typeof window.activeGameControls.action1 === 'function') {
                    window.activeGameControls.action1();
                } else {
                    console.log(`El juego ${gameId} no tiene una acción predeterminada para el botón 'Jugar'.`);
                }
            }
        });

    </script>
</body>
</html>
