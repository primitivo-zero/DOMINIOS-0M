<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameTok - ¡Tu plataforma de juegos!</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Estilos generales y reseteo */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-tap-highlight-color: transparent; /* Elimina el resaltado azul al tocar en móviles */
        }

        body {
            background-color: #000;
            color: #fff;
            overflow: hidden; /* Evita el scroll del body */
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.5s ease;
        }

        /* --- Centrado Global para todos los paneles --- */
        #main-menu, .container, #auth-modal, #tutorial-modal {
            position: absolute; /* Para que ocupen todo el espacio y puedan superponerse */
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column; /* Por defecto para apilar contenido */
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Evita barras de scroll internas a menos que se necesiten */
        }

        /* --- Menú de Inicio --- */
        #main-menu {
            background: linear-gradient(135deg, #1a0033, #000);
            z-index: 200;
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        #main-menu.hidden {
            opacity: 0;
            transform: translateY(-100vh);
            pointer-events: none; /* Deshabilita interacciones cuando está oculto */
        }

        #gametok-title {
            font-size: 8vw; /* Responsive font size */
            font-weight: bold;
            color: #ff0050;
            text-shadow: 0 0 20px rgba(255, 0, 80, 0.7);
            margin-bottom: 50px;
            animation: pulse 2s infinite alternate;
        }

        @keyframes pulse {
            from {
                transform: scale(1);
            }
            to {
                transform: scale(1.05);
            }
        }

        #game-carousel-container {
            width: 80%;
            height: 300px; /* Altura fija para el carrusel */
            perspective: 1000px; /* Para el efecto 3D */
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 50px;
            position: relative; /* Para posicionar el carrusel */
        }

        #game-carousel {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d; /* Permite transformar elementos hijos en 3D */
            animation: rotateCarousel 30s infinite linear; /* Animación de rotación */
        }

        @keyframes rotateCarousel {
            from {
                transform: rotateY(0deg);
            }
            to {
                transform: rotateY(360deg);
            }
        }

        .carousel-item {
            position: absolute;
            width: 200px; /* Tamaño de los ítems del carrusel */
            height: 150px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            opacity: 0.9;
            backface-visibility: hidden; /* Para que no se vea el reverso */
            cursor: pointer;
            transition: transform 0.5s ease, opacity 0.5s ease;
            user-select: none; /* Evita que el texto se seleccione al hacer clic */
        }

        .carousel-item img {
            max-width: 80%;
            max-height: 80%;
            object-fit: contain;
            margin-bottom: 5px;
        }

        /* Los transforms de cada item serán generados por JS */

        #start-button {
            padding: 15px 30px;
            font-size: 1.5em;
            font-weight: bold;
            background-color: #ff0050;
            color: #fff;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(255, 0, 80, 0.5);
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        #start-button:hover {
            background-color: #ff3373;
            transform: translateY(-3px);
        }

        /* --- Login / Register Pop-up --- */
        .auth-modal, .tutorial-modal {
            display: none; /* Oculto por defecto */
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 201; /* Por encima del menú principal */
        }

        .auth-modal-content, .tutorial-modal-content {
            background-color: #1a1a1a;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
            text-align: center;
            width: 90%;
            max-width: 450px;
            position: relative;
            transform: scale(0.9); /* Pequeña animación de entrada */
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .auth-modal.show .auth-modal-content,
        .tutorial-modal.show .tutorial-modal-content {
            transform: scale(1);
            opacity: 1;
        }


        .close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-button:hover,
        .close-button:focus {
            color: #fff;
            text-decoration: none;
        }

        .auth-modal-content h2, .tutorial-modal-content h2 {
            margin-bottom: 25px;
            color: #ff0050;
            font-size: 2em;
        }

        .auth-modal-content input {
            width: calc(100% - 20px);
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #333;
            border-radius: 8px;
            background-color: #0d0d0d;
            color: #fff;
            font-size: 1em;
        }

        .auth-modal-content input::placeholder {
            color: #777;
        }

        .auth-modal-content button, .tutorial-modal-content button {
            width: calc(100% - 20px);
            padding: 12px;
            background-color: #ff0050;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        .auth-modal-content button:hover, .tutorial-modal-content button:hover {
            background-color: #ff3373;
        }

        .auth-modal-content p {
            margin-top: 20px;
            font-size: 0.9em;
            color: #ccc;
        }

        .auth-modal-content p a {
            color: #ff0050;
            text-decoration: none;
            font-weight: bold;
        }

        /* --- Header / UI General (Juego) --- */
        .header {
            position: fixed; /* Fijo en la parte superior */
            top: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center; /* Centrar verticalmente */
            padding: 15px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), rgba(0,0,0,0));
            z-index: 100;
            display: none; /* Oculto inicialmente */
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: #ff0050;
        }

        .search-icon, .upload-icon {
            font-size: 20px;
            margin: 0 10px;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .search-icon:hover, .upload-icon:hover {
            color: #ff0050;
        }

        .container {
            display: none; /* Oculto inicialmente */
            /* Se superpone y toma el control cuando se inicia sesión */
            position: relative; /* Para posicionar los slides dentro */
        }

        #game-slides-container {
            width: 100%;
            height: 100%;
            position: relative; /* Para los slides absolutos */
            transition: transform 0.5s ease;
        }

        .game-slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column; /* Contenido apilado */
            justify-content: center; /* Centrar verticalmente */
            align-items: center; /* Centrar horizontalmente */
            background-size: cover;
            background-position: center;
            overflow: hidden; /* Por si el contenido del juego es grande */
        }

        .game-content-wrapper {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0,0,0,0.6); /* Fondo semi-transparente para el juego */
            padding-bottom: 80px; /* Espacio para el indicador y side-buttons */
        }

        .game-info {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            max-width: 90%;
            margin-bottom: 20px; /* Separación del área de juego */
            text-align: center;
        }

        .game-title {
            font-size: 28px;
            margin-bottom: 10px;
            color: #fff;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .game-desc {
            font-size: 16px;
            margin-bottom: 15px;
            color: #ddd;
        }

        .controls-info {
            font-size: 14px;
            margin-bottom: 10px;
            color: #aaa;
        }

        .control-buttons {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }

        .control-btn {
            background-color: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background-color: rgba(255,255,255,0.4);
        }

        .play-btn {
            background-color: #ff0050;
        }

        .play-btn:hover {
            background-color: #ff3373;
        }

        .game-play-area {
            /* Contenedor para el contenido específico de cada juego */
            display: flex;
            justify-content: center;
            align-items: center;
            /* Flexibilidad para el tamaño, pero se puede fijar si el juego lo requiere */
        }

        /* --- Botones laterales (Likes, Comentarios, Compartir) --- */
        .side-buttons {
            position: fixed;
            right: 15px;
            bottom: 100px; /* Ajuste para no superponer con el indicador */
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 50;
        }

        .side-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
            cursor: pointer;
        }

        .side-icon {
            background-color: rgba(255,255,255,0.1);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 5px;
            font-size: 20px;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .side-icon.liked {
            color: #ff0050;
        }

        .side-icon:hover {
            background-color: rgba(255,255,255,0.3);
        }

        .side-text {
            font-size: 12px;
            color: #ccc;
        }

        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #ff0050;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            margin-bottom: 5px;
            border: 2px solid white;
        }

        /* --- Indicadores de juego --- */
        .game-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            z-index: 100;
        }

        .indicator-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: rgba(255,255,255,0.5);
            margin: 0 5px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .indicator-dot.active {
            background-color: #ff0050;
            transform: scale(1.2);
        }

        /* --- Controles Móviles (Teclado virtual) --- */
        .mobile-controls {
            display: none; /* Oculto por defecto, se muestra con media query */
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 25vh; /* Aproximadamente un cuarto de la pantalla */
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 90;
            justify-content: space-around; /* Distribuir elementos */
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
            border-top-left-radius: 15px;
            border-top-right-radius: 15px;
        }

        .mobile-controls .d-pad-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            width: 180px; /* Tamaño fijo para el d-pad */
            height: 180px;
        }

        .mobile-btn {
            background-color: rgba(255,255,255,0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            user-select: none;
            -webkit-user-select: none;
            transition: background-color 0.2s ease;
            cursor: pointer;
        }

        .mobile-btn:active {
            background-color: rgba(255,255,255,0.4);
        }

        /* Posicionamiento en el grid del D-pad */
        .d-pad-group .mobile-btn[data-control="up"] { grid-area: 1 / 2 / 2 / 3; }
        .d-pad-group .mobile-btn[data-control="left"] { grid-area: 2 / 1 / 3 / 2; }
        .d-pad-group .mobile-btn[data-control="right"] { grid-area: 2 / 3 / 3 / 4; }
        .d-pad-group .mobile-btn[data-control="down"] { grid-area: 3 / 2 / 4 / 3; }
        /* El centro se mantiene vacío */
        .d-pad-group div:nth-child(5) { grid-area: 2 / 2 / 3 / 3; visibility: hidden; }


        .action-button-group {
            display: flex;
            gap: 15px;
        }

        .mobile-btn.action-btn {
            background-color: #ff0050;
            border-radius: 50%; /* Acción principal circular */
            width: 80px; /* Tamaño del botón de acción */
            height: 80px;
            font-size: 1.8em;
        }

        .mobile-btn.action-btn:active {
            background-color: #ff3373;
        }

        /* --- Media Queries para Móviles --- */
        @media (max-width: 768px) {
            #gametok-title {
                font-size: 12vw;
            }
            #game-carousel-container {
                height: 200px;
            }
            .carousel-item {
                width: 150px;
                height: 100px;
                font-size: 1.2em;
            }

            .game-content-wrapper {
                /* Para que el juego y la info tengan espacio cuando los controles estén */
                padding-bottom: calc(25vh + 80px); /* Altura de controles + padding para side-buttons */
            }

            .side-buttons {
                bottom: calc(25vh + 15px); /* Ajuste para no superponer con controles */
                right: 10px;
            }

            .mobile-controls {
                display: flex; /* Mostrar controles móviles */
            }
        }

        /* --- Estilos específicos de juegos (los que ya tenías) --- */
        #game1 { background: linear-gradient(135deg, #ff0050, #8400ff); } /* Memoria */
        #game2 { background: linear-gradient(135deg, #00ffaa, #0084ff); } /* Serpiente */
        #game3 { background: linear-gradient(135deg, #ffaa00, #ff0050); } /* Pong */
        #game4 { background: linear-gradient(135deg, #8400ff, #00ffaa); } /* Flappy Bird */
        #game5 { background: linear-gradient(135deg, #0084ff, #ffaa00); } /* Breakout */


        /* Estilos de las áreas de juego */
        .memory-game {
            display: grid;
            grid-template-columns: repeat(4, 70px); /* Más pequeño para centrar mejor */
            grid-gap: 8px;
            background-color: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 10px;
        }

        .memory-card {
            width: 70px;
            height: 70px;
            background-color: rgba(255,255,255,0.2);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
            transform-style: preserve-3d; /* Para el efecto de volteo 3D */
            position: relative;
        }
        .memory-card .front, .memory-card .back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden; /* Oculta la cara trasera al voltear */
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
        }
        .memory-card .back {
            background-color: white;
            color: #333;
            transform: rotateY(180deg); /* La cara trasera está volteada inicialmente */
        }
        .memory-card.flipped {
            transform: rotateY(180deg); /* Voltea la tarjeta para mostrar la cara trasera */
        }
        .memory-card.matched .front, .memory-card.matched .back {
            opacity: 0.5;
        }

        #snake-game, #pong-game, #flappy-game, #breakout-game {
            display: flex;
            justify-content: center;
            align-items: center;
            width: auto; /* Dejar que el canvas/contenido interno defina el ancho */
            height: auto; /* Dejar que el canvas/contenido interno defina el alto */
            max-width: 95vw; /* Limitar para móviles */
            max-height: 50vh; /* Limitar para móviles, dejando espacio a info y controles */
            border-radius: 5px;
            overflow: hidden; /* Por si el juego tiene elementos que se salen */
        }

        #snake-canvas {
            background-color: #333; /* Fondo del canvas de la serpiente */
            border-radius: 5px;
        }

        #pong-game {
            width: 400px;
            height: 250px;
            position: relative;
            background-color: rgba(0,0,0,0.2);
        }

        .paddle {
            position: absolute;
            width: 15px;
            height: 80px;
            background-color: white;
        }

        #left-paddle { left: 10px; }
        #right-paddle { right: 10px; }

        .ball {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: white;
            border-radius: 50%;
        }

        .score {
            position: absolute;
            top: 10px;
            font-size: 24px;
            color: white;
            z-index: 10;
        }

        #left-score { left: 150px; }
        #right-score { right: 150px; }

        #flappy-game {
            width: 300px;
            height: 400px;
            position: relative;
            background-color: #70c5ce;
        }

        #bird {
            position: absolute;
            width: 40px;
            height: 30px;
            background-color: #ffcc00;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
        }

        .pipe {
            position: absolute;
            width: 60px;
            background-color: #74BF2E;
        }

        .pipe.top { top: 0; }
        .pipe.bottom { bottom: 0; }

        #breakout-canvas {
            background-color: #333;
            border-radius: 5px;
        }

        /* Estilos para el contenido del tutorial */
        .tutorial-modal-content {
            background-color: #1a1a1a;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
            text-align: left; /* Alineado a la izquierda para mejor lectura */
            width: 90%;
            max-width: 600px;
            max-height: 80vh; /* Para que no ocupe toda la pantalla en móviles */
            overflow-y: auto; /* Scroll si el contenido es largo */
        }
        .tutorial-modal-content p {
            margin-bottom: 10px;
            line-height: 1.6;
            color: #ccc;
        }
        .tutorial-modal-content ul {
            margin-left: 20px;
            margin-bottom: 15px;
            color: #ccc;
        }
        .tutorial-modal-content ul li {
            margin-bottom: 5px;
        }
        .tutorial-modal-content strong {
            color: #ff0050;
        }

    </style>
</head>
<body>

    <div id="main-menu">
        <h1 id="gametok-title">GameTok</h1>
        <div id="game-carousel-container">
            <div id="game-carousel">
                </div>
        </div>
        <button id="start-button">Comenzar</button>
    </div>

    <div class="container">
        <div class="header">
            <div class="logo">GameTok</div>
            <div>
                <i class="fas fa-search search-icon"></i>
                <i class="fas fa-cloud-upload-alt upload-icon"></i>
            </div>
        </div>

        <div id="game-slides-container">
            </div>

        <div class="side-buttons">
            <div class="side-button">
                <div class="avatar">U</div> <span class="side-text">Usuario</span>
            </div>
            <div class="side-button" id="like-button">
                <div class="side-icon"><i class="fas fa-heart"></i></div>
                <span class="side-text" id="likes-count">0</span>
            </div>
            <div class="side-button">
                <div class="side-icon"><i class="fas fa-comment-dots"></i></div>
                <span class="side-text">Comentarios</span>
            </div>
            <div class="side-button">
                <div class="side-icon"><i class="fas fa-share"></i></div>
                <span class="side-text">Compartir</span>
            </div>
        </div>

        <div class="game-indicator">
            </div>

        <div class="mobile-controls">
            <div class="d-pad-group">
                <div class="mobile-btn" data-control="up"><i class="fas fa-arrow-up"></i></div>
                <div class="mobile-btn" data-control="left"><i class="fas fa-arrow-left"></i></div>
                <div class="mobile-btn" data-control="right"><i class="fas fa-arrow-right"></i></div>
                <div class="mobile-btn" data-control="down"><i class="fas fa-arrow-down"></i></div>
                <div class="mobile-btn" style="visibility: hidden;"></div> </div>
            <div class="action-button-group">
                <div class="mobile-btn action-btn" data-control="action1"><i class="fas fa-hand-pointer"></i></div>
                <div class="mobile-btn action-btn" data-control="action2"><i class="fas fa-redo"></i></div>
            </div>
        </div>

    </div>

    <div id="auth-modal" class="auth-modal">
        <div class="auth-modal-content">
            <span class="close-button">&times;</span>
            <h2 id="auth-title">Iniciar Sesión</h2>
            <input type="text" id="username" placeholder="Nombre de usuario" required>
            <input type="password" id="password" placeholder="Contraseña" required>
            <button id="auth-submit-button">Iniciar Sesión</button>
            <p>¿No tienes una cuenta? <a href="#" id="toggle-auth">Regístrate aquí</a></p>
        </div>
    </div>

    <div id="tutorial-modal" class="tutorial-modal">
        <div class="tutorial-modal-content">
            <span class="close-button" id="close-tutorial-button">&times;</span>
            <h2 id="tutorial-title">Tutorial de Juego</h2>
            <div id="tutorial-content">
                </div>
            <button id="close-tutorial-btn">Entendido</button>
        </div>
    </div>

    <script>
        // Datos de los juegos
        const games = [
            {
                id: 'game1',
                name: 'Memoria',
                description: '¡Pon a prueba tu memoria con este divertido juego de cartas! Encuentra las parejas en el menor tiempo posible.',
                controls: 'Clic/Toque para voltear las cartas.',
                gameContent: '<div class="memory-game"></div>',
                tutorial: `
                    <h3>Cómo Jugar a la Memoria:</h3>
                    <ul>
                        <li>El objetivo es encontrar todas las parejas de cartas iguales.</li>
                        <li>Haz clic o toca en dos cartas para voltearlas.</li>
                        <li>Si las cartas son iguales, se quedarán boca arriba.</li>
                        <li>Si son diferentes, se volverán a ocultar después de un breve momento.</li>
                        <li>Intenta recordar la posición de las cartas para hacer parejas más rápido.</li>
                    </ul>
                    <p><strong>Controles:</strong> Clic izquierdo del ratón o toque en pantalla.</p>
                `
            },
            {
                id: 'game2',
                name: 'Serpiente',
                description: 'Alimenta a la serpiente y hazla crecer sin chocar contra las paredes o su propio cuerpo. ¡Cada manzana te hace más largo!',
                controls: 'Flechas del teclado (↑↓←→) o ASWD para mover la serpiente. D-Pad en móviles.',
                gameContent: '<div id="snake-game"><canvas id="snake-canvas" width="300" height="300"></canvas></div>',
                tutorial: `
                    <h3>Cómo Jugar a la Serpiente:</h3>
                    <ul>
                        <li>Controla a la serpiente para que coma las manzanas que aparecen en el tablero.</li>
                        <li>Cada vez que come una manzana, la serpiente se hace más larga y ganas puntos.</li>
                        <li>Evita chocar contra los bordes del tablero o contra tu propio cuerpo.</li>
                        <li>Si chocas, el juego termina.</li>
                    </ul>
                    <p><strong>Controles:</strong></p>
                    <ul>
                        <li><strong>PC:</strong> Teclas de flecha (↑↓←→) o ASWD para cambiar la dirección.</li>
                        <li><strong>Móvil:</strong> D-Pad virtual en pantalla.</li>
                    </ul>
                `
            },
            {
                id: 'game3',
                name: 'Pong',
                description: 'El clásico juego de ping-pong. Mueve tu paleta para golpear la pelota y evitar que tu oponente anote.',
                controls: 'Flechas Arriba/Abajo o WS para mover la paleta izquierda. D-Pad en móviles (controla la paleta de la izquierda).',
                gameContent: '<div id="pong-game"><div class="paddle" id="left-paddle"></div><div class="paddle" id="right-paddle"></div><div class="ball"></div><div class="score" id="left-score">0</div><div class="score" id="right-score">0</div></div>',
                tutorial: `
                    <h3>Cómo Jugar a Pong:</h3>
                    <ul>
                        <li>Eres la paleta de la izquierda. Tu objetivo es no dejar que la pelota pase por tu lado.</li>
                        <li>Mueve tu paleta hacia arriba y hacia abajo para interceptar la pelota.</li>
                        <li>Si la pelota pasa por tu lado, tu oponente (la paleta de la derecha, controlada por IA) anotará un punto.</li>
                        <li>Gana el primero en alcanzar una puntuación determinada (por ejemplo, 7 puntos).</li>
                    </ul>
                    <p><strong>Controles:</strong></p>
                    <ul>
                        <li><strong>PC:</strong> Teclas <strong>W</strong> (arriba) y <strong>S</strong> (abajo) o <strong>Flechas Arriba/Abajo</strong> para mover tu paleta.</li>
                        <li><strong>Móvil:</strong> D-Pad virtual en pantalla (Arriba/Abajo).</li>
                    </ul>
                `
            },
            {
                id: 'game4',
                name: 'Flappy Bird',
                description: 'Ayuda al pájaro a volar a través de los obstáculos. ¡Cada tubería es un punto, pero cuidado con chocarte!',
                controls: 'Espacio o clic/toque para aletear. Botón de Acción en móviles.',
                gameContent: '<div id="flappy-game"><div id="bird"></div></div>',
                tutorial: `
                    <h3>Cómo Jugar a Flappy Bird:</h3>
                    <ul>
                        <li>Haz que el pájaro aletee para que no caiga al suelo y lo guíe a través de los huecos entre las tuberías.</li>
                        <li>Cada vez que pases por un par de tuberías, ganas un punto.</li>
                        <li>Si el pájaro golpea una tubería o cae al suelo, el juego termina.</li>
                    </ul>
                    <p><strong>Controles:</strong></p>
                    <ul>
                        <li><strong>PC:</strong> Pulsa la tecla <strong>Espacio</strong> o haz <strong>clic</strong> en la pantalla para que el pájaro aletee.</li>
                        <li><strong>Móvil:</strong> Toca en la pantalla o usa el Botón de Acción virtual.</li>
                    </ul>
                `
            },
            {
                id: 'game5',
                name: 'Breakout',
                description: 'Destruye todos los bloques con tu pelota y paleta. ¡Sé preciso para limpiar el tablero!',
                controls: 'Flechas Izquierda/Derecha o AD para mover la paleta. D-Pad en móviles.',
                gameContent: '<div id="breakout-game"><canvas id="breakout-canvas" width="400" height="300"></canvas></div>',
                tutorial: `
                    <h3>Cómo Jugar a Breakout:</h3>
                    <ul>
                        <li>Controla la paleta en la parte inferior de la pantalla.</li>
                        <li>El objetivo es rebotar la pelota para destruir todos los bloques de colores en la parte superior.</li>
                        <li>Si la pelota cae por debajo de la paleta, pierdes una vida.</li>
                        <li>Tienes un número limitado de vidas. Cuando se agotan, el juego termina.</li>
                    </ul>
                    <p><strong>Controles:</strong></p>
                    <ul>
                        <li><strong>PC:</strong> Teclas <strong>A</strong> (izquierda) y <strong>D</strong> (derecha) o <strong>Flechas Izquierda/Derecha</strong> para mover tu paleta.</li>
                        <li><strong>Móvil:</strong> D-Pad virtual en pantalla (Izquierda/Derecha).</li>
                    </ul>
                `
            }
        ];

        let currentActiveGame = 0; // Índice del juego actual
        let isAuthModalOpen = false;
        let isTutorialModalOpen = false;
        let isMobile = window.innerWidth <= 768; // Para detectar si es móvil

        // Referencias a elementos del DOM
        const mainMenu = document.getElementById('main-menu');
        const startButton = document.getElementById('start-button');
        const authModal = document.getElementById('auth-modal');
        const closeAuthButton = authModal.querySelector('.close-button');
        const toggleAuthLink = document.getElementById('toggle-auth');
        const authTitle = document.getElementById('auth-title');
        const authSubmitButton = document.getElementById('auth-submit-button');
        const gameCarousel = document.getElementById('game-carousel');
        const gameSlidesContainer = document.getElementById('game-slides-container');
        const gameIndicator = document.querySelector('.game-indicator');
        const appContainer = document.querySelector('.container');
        const header = document.querySelector('.header');
        const likeButton = document.getElementById('like-button');
        const likesCount = document.getElementById('likes-count');
        const mobileControls = document.querySelector('.mobile-controls');
        const tutorialModal = document.getElementById('tutorial-modal');
        const tutorialTitle = document.getElementById('tutorial-title');
        const tutorialContent = document.getElementById('tutorial-content');
        const closeTutorialButton = document.getElementById('close-tutorial-button');
        const closeTutorialBtn = document.getElementById('close-tutorial-btn'); // Botón "Entendido"


        // --- Funciones del Menú de Inicio y Carrusel ---

        // Genera los ítems del carrusel dinámicamente
        function generateCarouselItems() {
            const numGames = games.length;
            const angleStep = 360 / numGames;
            const radius = 300; // Radio de la órbita del carrusel

            gameCarousel.innerHTML = ''; // Limpiar carrusel existente

            games.forEach((game, index) => {
                const carouselItem = document.createElement('div');
                carouselItem.classList.add('carousel-item');
                // Podrías añadir una imagen si la tienes en tus datos de juego
                // carouselItem.innerHTML = `<img src="images/${game.id}.png" alt="${game.name}"><span>${game.name}</span>`;
                carouselItem.innerHTML = `<span>${game.name}</span>`; // Por ahora solo el nombre

                carouselItem.setAttribute('data-game-id', game.id);

                // Calcular la transformación para distribuir uniformemente
                // Posicionar con rotateY y translateZ para el efecto 3D
                const transformValue = `rotateY(${index * angleStep}deg) translateZ(${radius}px)`;
                carouselItem.style.transform = transformValue;
                // Asigna colores aleatorios al carrusel para que se vea más dinámico
                carouselItem.style.background = `linear-gradient(45deg, ${getRandomColor()}, ${getRandomColor()})`;

                carouselItem.addEventListener('click', () => {
                    // Centrar el juego seleccionado en el carrusel al hacer clic
                    // Se calcula el ángulo necesario para que el elemento rote al frente
                    const targetAngle = -(index * angleStep);
                    gameCarousel.style.transition = 'transform 0.8s ease-in-out';
                    gameCarousel.style.transform = `rotateY(${targetAngle}deg)`;
                    gameCarousel.style.animationPlayState = 'paused'; // Pausar la animación automática

                    // Reanudar la animación después de un tiempo si no hay otra interacción
                    setTimeout(() => {
                        gameCarousel.style.transition = ''; // Resetear transición para que la animación automática funcione
                        gameCarousel.style.animationPlayState = 'running';
                    }, 2500); // Reanudar después de 2.5 segundos
                });

                gameCarousel.appendChild(carouselItem);
            });
        }

        // Genera los slides de los juegos y los indicadores
        function generateGameSlides() {
            gameSlidesContainer.innerHTML = ''; // Limpiar slides existentes
            gameIndicator.innerHTML = ''; // Limpiar indicadores existentes

            games.forEach((game, index) => {
                // Crear el slide del juego
                const gameSlide = document.createElement('div');
                gameSlide.classList.add('game-slide');
                gameSlide.id = `slide-${game.id}`;

                // Contenido del slide
                gameSlide.innerHTML = `
                    <div class="game-content-wrapper">
                        <div class="game-info">
                            <h2 class="game-title">${game.name}</h2>
                            <p class="game-desc">${game.description}</p>
                            <p class="controls-info">Controles: ${game.controls}</p>
                            <div class="control-buttons">
                                <button class="control-btn play-btn" data-game-id="${game.id}">Jugar</button>
                                <button class="control-btn tutorial-btn" data-game-id="${game.id}">Tutorial</button>
                            </div>
                        </div>
                        <div class="game-play-area" id="game-area-${game.id}">
                            ${game.gameContent}
                        </div>
                    </div>
                `;
                gameSlidesContainer.appendChild(gameSlide);

                // Crear el punto indicador
                const dot = document.createElement('div');
                dot.classList.add('indicator-dot');
                dot.setAttribute('data-slide-index', index);
                dot.addEventListener('click', () => {
                    showGame(index);
                });
                gameIndicator.appendChild(dot);
            });

            // Activar el primer juego y su indicador
            showGame(currentActiveGame);
        }

        // Muestra el juego especificado por su índice
        function showGame(index) {
            currentActiveGame = index;
            const translateYValue = -index * 100; // Desplaza el contenedor verticalmente
            gameSlidesContainer.style.transform = `translateY(${translateYValue}vh)`;

            // Actualizar puntos indicadores
            document.querySelectorAll('.indicator-dot').forEach((dot, idx) => {
                if (idx === index) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });

            // Reiniciar o preparar el juego actual
            initializeGameSpecificContent(games[currentActiveGame].id);
        }

        // Navegación con la rueda del ratón
        function handleScroll(event) {
            // No navegar si un modal está abierto
            if (isAuthModalOpen || isTutorialModalOpen) return;

            event.preventDefault(); // Evitar el scroll predeterminado de la página
            const delta = event.deltaY || event.detail || event.wheelDelta; // Detecta la dirección de la rueda

            if (delta > 0) { // Desplazarse hacia abajo (siguiente juego)
                if (currentActiveGame < games.length - 1) {
                    showGame(currentActiveGame + 1);
                }
            } else { // Desplazarse hacia arriba (juego anterior)
                if (currentActiveGame > 0) {
                    showGame(currentActiveGame - 1);
                }
            }
        }

        // Manejo de Swipe para navegación en móviles
        let touchStartY = 0;
        let touchEndY = 0;

        function handleTouchStart(event) {
            if (isAuthModalOpen || isTutorialModalOpen) return;
            touchStartY = event.touches[0].clientY;
        }

        function handleTouchMove(event) {
            if (isAuthModalOpen || isTutorialModalOpen) return;
            touchEndY = event.touches[0].clientY;
        }

        function handleTouchEnd() {
            if (isAuthModalOpen || isTutorialModalOpen) return;
            const swipeThreshold = 50; // Mínimo de píxeles para considerar un swipe

            if (touchStartY - touchEndY > swipeThreshold) { // Swipe Up (siguiente juego)
                if (currentActiveGame < games.length - 1) {
                    showGame(currentActiveGame + 1);
                }
            } else if (touchEndY - touchStartY > swipeThreshold) { // Swipe Down (juego anterior)
                if (currentActiveGame > 0) {
                    showGame(currentActiveGame - 1);
                }
            }
            // Resetear valores para el siguiente swipe
            touchStartY = 0;
            touchEndY = 0;
        }

        // --- Funcionalidad de Autenticación (Login/Registro) ---

        startButton.addEventListener('click', () => {
            mainMenu.classList.add('hidden'); // Oculta el menú principal con animación
            setTimeout(() => {
                authModal.style.display = 'flex'; // Muestra el modal de login
                authModal.classList.add('show'); // Activa la animación del modal
                isAuthModalOpen = true;
            }, 500); // Esperar que termine la animación de ocultar el menú
        });

        closeAuthButton.addEventListener('click', () => {
            authModal.classList.remove('show'); // Desactiva la animación del modal
            setTimeout(() => {
                authModal.style.display = 'none'; // Oculta el modal de login
                mainMenu.classList.remove('hidden'); // Volver al menú principal
                isAuthModalOpen = false;
            }, 300); // Esperar que termine la animación de ocultar el modal
        });

        toggleAuthLink.addEventListener('click', (e) => {
            e.preventDefault(); // Evita que el enlace recargue la página
            if (authTitle.textContent === 'Iniciar Sesión') {
                authTitle.textContent = 'Registrarse';
                authSubmitButton.textContent = 'Registrarse';
                toggleAuthLink.textContent = 'Inicia Sesión aquí';
            } else {
                authTitle.textContent = 'Iniciar Sesión';
                authSubmitButton.textContent = 'Iniciar Sesión';
                toggleAuthLink.textContent = 'Regístrate aquí';
            }
        });

        authSubmitButton.addEventListener('click', () => {
            // Aquí iría la lógica real de autenticación (AJAX a un servidor, etc.)
            alert(`Simulando ${authTitle.textContent} para usuario: ${document.getElementById('username').value}`);
            authModal.classList.remove('show');
            setTimeout(() => {
                authModal.style.display = 'none';
                isAuthModalOpen = false;
                // Mostrar la interfaz principal de la app
                appContainer.style.display = 'flex';
                header.style.display = 'flex';
                updateGameControlsVisibility(); // Asegurarse de que los controles móviles se muestren si es necesario
                showGame(currentActiveGame); // Mostrar el primer juego o el actual
            }, 300);
        });

        // --- Funcionalidad de Tutorial ---

        // Delegación de eventos para los botones de tutorial
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('tutorial-btn')) {
                const gameId = e.target.getAttribute('data-game-id');
                const game = games.find(g => g.id === gameId);
                if (game && game.tutorial) {
                    tutorialTitle.textContent = `Tutorial: ${game.name}`;
                    tutorialContent.innerHTML = game.tutorial;
                    tutorialModal.style.display = 'flex'; // Muestra el modal
                    tutorialModal.classList.add('show'); // Activa la animación
                    isTutorialModalOpen = true;
                }
            }
        });

        // Cerrar tutorial
        closeTutorialButton.addEventListener('click', () => {
            tutorialModal.classList.remove('show');
            setTimeout(() => {
                tutorialModal.style.display = 'none';
                isTutorialModalOpen = false;
            }, 300);
        });
        closeTutorialBtn.addEventListener('click', () => { // Botón "Entendido" dentro del tutorial
            tutorialModal.classList.remove('show');
            setTimeout(() => {
                tutorialModal.style.display = 'none';
                isTutorialModalOpen = false;
            }, 300);
        });


        // --- Funcionalidad de Botones Laterales (Likes, etc.) ---

        let likes = 0;
        let liked = false;
        likeButton.addEventListener('click', () => {
            if (!liked) {
                likes++;
                likeButton.querySelector('.side-icon').classList.add('liked');
                liked = true;
            } else {
                likes--;
                likeButton.querySelector('.side-icon').classList.remove('liked');
                liked = false;
            }
            likesCount.textContent = likes;
        });

        // --- Manejo de Controles de Juego (Teclado y Móviles) ---

        function updateGameControlsVisibility() {
            if (isMobile) {
                mobileControls.style.display = 'flex';
            } else {
                mobileControls.style.display = 'none';
            }
        }

        // Event listeners para controles móviles (D-pad y botones de acción)
        document.querySelectorAll('.mobile-btn').forEach(button => {
            button.addEventListener('pointerdown', (e) => {
                e.preventDefault(); // Evita el comportamiento predeterminado del navegador
                const control = button.getAttribute('data-control');
                console.log(`Control móvil presionado: ${control}`);
                // Llama a la función de control específica del juego activo
                if (window.activeGameControls && typeof window.activeGameControls[control] === 'function') {
                    window.activeGameControls[control]();
                }
            });
            // Puedes agregar 'pointerup' si necesitas detectar cuándo se suelta el botón móvil
            // button.addEventListener('pointerup', (e) => {
            //     const control = button.getAttribute('data-control');
            //     if (window.activeGameControls && typeof window.activeGameControls.stop === 'function') {
            //         window.activeGameControls.stop(control); // Llama a una función 'stop' si existe
            //     }
            // });
        });

        // Objeto global para almacenar funciones de control de juego
        // Cada juego al inicializarse, sobrescribirá estas funciones con las suyas.
        window.activeGameControls = {};
        // Objeto para rastrear qué teclas están actualmente presionadas, útil para movimiento continuo
        const pressedKeys = {};

        // Event listener para teclado (controles de juego ASWD y Flechas)
        document.addEventListener('keydown', (e) => {
            // No procesar si un modal está abierto o la app principal no es visible
            if (isAuthModalOpen || isTutorialModalOpen || appContainer.style.display !== 'flex') return;

            // Mapeo de teclas a acciones de control
            let controlAction = null;
            switch (e.key.toLowerCase()) { // Convertir a minúsculas para ASWD
                case 'arrowup':
                case 'w':
                    controlAction = 'up';
                    break;
                case 'arrowdown':
                case 's':
                    controlAction = 'down';
                    break;
                case 'arrowleft':
                case 'a':
                    controlAction = 'left';
                    break;
                case 'arrowright':
                case 'd':
                    controlAction = 'right';
                    break;
                case ' ': // Espacio para acción o salto (Flappy Bird)
                    controlAction = 'action1';
                    break;
                case 'enter': // Enter para iniciar/pausar o una segunda acción
                    controlAction = 'action2';
                    break;
            }

            // Si se detecta una acción y la tecla no está ya registrada como presionada
            if (controlAction && window.activeGameControls && typeof window.activeGameControls[controlAction] === 'function' && !pressedKeys[controlAction]) {
                e.preventDefault(); // Evita el scroll u otras acciones predeterminadas del navegador
                window.activeGameControls[controlAction](); // Ejecuta la función de control del juego
                pressedKeys[controlAction] = true; // Marca la tecla como presionada
            }
        });

        // Event listener para soltar teclas (importante para detener movimiento continuo)
        document.addEventListener('keyup', (e) => {
            // No procesar si un modal está abierto o la app principal no es visible
            if (isAuthModalOpen || isTutorialModalOpen || appContainer.style.display !== 'flex') return;

            let controlAction = null;
            switch (e.key.toLowerCase()) {
                case 'arrowleft':
                case 'a':
                    controlAction = 'left';
                    break;
                case 'arrowright':
                case 'd':
                    controlAction = 'right';
                    break;
            }

            if (controlAction) {
                // Si la acción es de movimiento y el juego tiene una función para detenerlo
                if (window.activeGameControls && typeof window.activeGameControls.stopMove === 'function') {
                    window.activeGameControls.stopMove(controlAction);
                }
                delete pressedKeys[controlAction]; // Desmarca la tecla como presionada
            }
        });

        // --- Inicialización de Contenido Específico de Juegos ---
        function initializeGameSpecificContent(gameId) {
            // Limpiar controles previos para el juego anterior
            window.activeGameControls = {};

            // Aquí se ejecutarán funciones específicas para cada juego,
            // que se encargarán de inicializar su lógica y elementos del DOM.
            // Esto asegura que cada juego se reinicie o prepare correctamente.
            switch (gameId) {
                case 'game1': // Memoria
                    console.log('Inicializando juego de Memoria...');
                    initializeMemoryGame();
                    break;
                case 'game2': // Serpiente
                    console.log('Inicializando juego de Serpiente...');
                    initializeSnakeGame();
                    break;
                case 'game3': // Pong
                    console.log('Inicializando juego de Pong...');
                    initializePongGame();
                    break;
                case 'game4': // Flappy Bird
                    console.log('Inicializando juego de Flappy Bird...');
                    initializeFlappyBirdGame();
                    break;
                case 'game5': // Breakout
                    console.log('Inicializando juego de Breakout...');
                    initializeBreakoutGame();
                    break;
                default:
                    console.log('Juego no reconocido o sin lógica de inicialización específica.');
            }
        }

        // --- Lógica de Juegos Individuales (Esqueletos Funcionales) ---

        // Game 1: Memoria
        function initializeMemoryGame() {
            const memoryGameDiv = document.querySelector(`#game-area-game1 .memory-game`);
            if (!memoryGameDiv) return;

            memoryGameDiv.innerHTML = ''; // Limpiar cualquier juego anterior
            const icons = ['⭐', '🍄', '👻', '💎', '🚀', '🌈', '⚡', '🤖'];
            let cards = [...icons, ...icons]; // Duplicar para parejas
            cards.sort(() => Math.random() - 0.5); // Mezclar aleatoriamente

            let flippedCards = [];
            let matchedCards = [];
            let canFlip = true; // Para evitar que el usuario voltee más de 2 cartas

            cards.forEach((icon, index) => {
                const card = document.createElement('div');
                card.classList.add('memory-card');
                card.innerHTML = `<div class="front">?</div><div class="back">${icon}</div>`;
                card.dataset.index = index;
                card.dataset.value = icon;
                card.addEventListener('click', () => flipCard(card));
                memoryGameDiv.appendChild(card);
            });

            function flipCard(card) {
                if (!canFlip || flippedCards.length >= 2 || card.classList.contains('flipped') || card.classList.contains('matched')) {
                    return; // No permitir voltear si ya hay dos volteadas, no se puede voltear, o ya está volteada/emparejada
                }

                card.classList.add('flipped');
                flippedCards.push(card);

                if (flippedCards.length === 2) {
                    canFlip = false; // Bloquear más volteos
                    setTimeout(checkForMatch, 1000); // Esperar 1 segundo antes de comprobar
                }
            }

            function checkForMatch() {
                const [card1, card2] = flippedCards;
                if (card1.dataset.value === card2.dataset.value) {
                    card1.classList.add('matched');
                    card2.classList.add('matched');
                    matchedCards.push(card1, card2);
                    if (matchedCards.length === cards.length) {
                        alert('¡Felicidades, encontraste todas las parejas!');
                        // Opcional: Reiniciar el juego automáticamente
                        // initializeMemoryGame();
                    }
                } else {
                    card1.classList.remove('flipped');
                    card2.classList.remove('flipped');
                }
                flippedCards = [];
                canFlip = true; // Permitir voltear de nuevo
            }

            // Exponer un control para reiniciar el juego, por ejemplo.
            window.activeGameControls = {
                action2: () => { // Botón de Reiniciar
                    console.log('Reiniciando juego de Memoria...');
                    initializeMemoryGame();
                }
            };
        }


        // Game 2: Serpiente
        let snakeGameInterval = null; // Para almacenar la instancia del juego
        function initializeSnakeGame() {
            const canvas = document.getElementById('snake-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const gridSize = 15; // Tamaño de cada segmento de la serpiente
            const tileCount = canvas.width / gridSize; // Número de celdas en el tablero

            let snake = [{ x: 10, y: 10 }]; // Posición inicial de la serpiente
            let food = {};
            let dx = 0; // Dirección horizontal (1: derecha, -1: izquierda)
            let dy = 0; // Dirección vertical (1: abajo, -1: arriba)
            let score = 0;
            let gamePaused = false;
            let changingDirection = false; // Para evitar giros dobles rápidos

            function generateFood() {
                food = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
                // Asegurarse de que la comida no aparezca en la serpiente
                for (let i = 0; i < snake.length; i++) {
                    if (food.x === snake[i].x && food.y === snake[i].y) {
                        generateFood(); // Regenerar si la comida está en la serpiente
                    }
                }
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpiar el canvas
                ctx.fillStyle = '#333'; // Fondo del canvas
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Dibujar comida
                ctx.fillStyle = 'red';
                ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize, gridSize);

                // Dibujar serpiente
                ctx.fillStyle = 'lime';
                snake.forEach(segment => {
                    ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
                    ctx.strokeStyle = '#006600'; // Borde oscuro
                    ctx.strokeRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
                });
            }

            function moveSnake() {
                if (gamePaused) return; // No mover si está pausado

                if (gameOver()) {
                    clearInterval(snakeGameInterval);
                    alert(`¡Juego Terminado! Puntuación: ${score}`);
                    return;
                }

                const head = { x: snake[0].x + dx, y: snake[0].y + dy };
                snake.unshift(head); // Añadir nueva cabeza

                // Si come la comida
                if (head.x === food.x && head.y === food.y) {
                    score++;
                    generateFood(); // Generar nueva comida
                } else {
                    snake.pop(); // Quitar la cola
                }
                changingDirection = false; // Permitir cambiar de dirección de nuevo
                draw();
            }

            function gameOver() {
                // Chocar con la pared
                const hitLeftWall = snake[0].x < 0;
                const hitRightWall = snake[0].x >= tileCount;
                const hitTopWall = snake[0].y < 0;
                const hitBottomWall = snake[0].y >= tileCount;

                if (hitLeftWall || hitRightWall || hitTopWall || hitBottomWall) return true;

                // Chocar con el propio cuerpo (empezar a comprobar desde el 4º segmento)
                for (let i = 4; i < snake.length; i++) {
                    if (snake[i].x === snake[0].x && snake[i].y === snake[0].y) return true;
                }
                return false;
            }

            function changeDirection(newDx, newDy) {
                if (changingDirection || (dx === -newDx && newDx !== 0) || (dy === -newDy && newDy !== 0)) {
                    // Evitar giros múltiples en un mismo frame o giro de 180 grados
                    return;
                }
                changingDirection = true;
                dx = newDx;
                dy = newDy;
            }

            function togglePause() {
                gamePaused = !gamePaused;
                if (!gamePaused) {
                    snakeGameInterval = setInterval(moveSnake, 100);
                    console.log('Juego de Serpiente reanudado');
                } else {
                    clearInterval(snakeGameInterval);
                    console.log('Juego de Serpiente pausado');
                }
            }

            function resetSnakeGame() {
                clearInterval(snakeGameInterval);
                snake = [{ x: 10, y: 10 }];
                dx = 0; dy = 0; score = 0;
                gamePaused = false;
                generateFood();
                draw();
                snakeGameInterval = setInterval(moveSnake, 100);
                console.log('Juego de Serpiente reiniciado');
            }

            // Exponer controles al objeto global
            window.activeGameControls = {
                up: () => changeDirection(0, -1),
                down: () => changeDirection(0, 1),
                left: () => changeDirection(-1, 0),
                right: () => changeDirection(1, 0),
                action1: togglePause, // Botón de acción para pausar/reanudar
                action2: resetSnakeGame // Botón de acción para reiniciar
            };

            // Iniciar el juego
            resetSnakeGame(); // Llamar para asegurar un estado inicial limpio
        }

        // Game 3: Pong
        let pongGameInterval;
        let leftPaddleY;
        let rightPaddleY;
        let ballX;
        let ballY;
        let ballDx; // Velocidad de la pelota en X
        let ballDy; // Velocidad de la pelota en Y
        let leftScore;
        let rightScore;
        const paddleSpeed = 8; // Velocidad de las paletas
        let pongGamePaused = false;

        function initializePongGame() {
            const pongGameDiv = document.getElementById('pong-game');
            if (!pongGameDiv) return;

            const leftPaddle = document.getElementById('left-paddle');
            const rightPaddle = document.getElementById('right-paddle');
            const ball = document.querySelector('.ball');
            const leftScoreElem = document.getElementById('left-score');
            const rightScoreElem = document.getElementById('right-score');

            // Resetear estado
            leftPaddleY = pongGameDiv.offsetHeight / 2 - leftPaddle.offsetHeight / 2;
            rightPaddleY = pongGameDiv.offsetHeight / 2 - rightPaddle.offsetHeight / 2;
            resetBall(); // Inicializa la posición y dirección de la pelota
            leftScore = 0; rightScore = 0;
            leftScoreElem.textContent = leftScore;
            rightScoreElem.textContent = rightScore;
            pongGamePaused = false;

            function updatePongGame() {
                if (pongGamePaused) return;

                // Mover paletas (simulación de IA básica para la derecha)
                if (ballY > rightPaddleY + rightPaddle.offsetHeight / 2) {
                    rightPaddleY += Math.min(paddleSpeed, ballY - (rightPaddleY + rightPaddle.offsetHeight / 2));
                } else if (ballY < rightPaddleY + rightPaddle.offsetHeight / 2) {
                    rightPaddleY -= Math.min(paddleSpeed, (rightPaddleY + rightPaddle.offsetHeight / 2) - ballY);
                }

                // Limitar paletas a los bordes
                leftPaddleY = Math.max(0, Math.min(pongGameDiv.offsetHeight - leftPaddle.offsetHeight, leftPaddleY));
                rightPaddleY = Math.max(0, Math.min(pongGameDiv.offsetHeight - rightPaddle.offsetHeight, rightPaddleY));

                leftPaddle.style.top = `${leftPaddleY}px`;
                rightPaddle.style.top = `${rightPaddleY}px`;

                // Mover pelota
                ballX += ballDx;
                ballY += ballDy;

                // Rebote en paredes superior/inferior
                if (ballY <= 0 || ballY >= pongGameDiv.offsetHeight - ball.offsetHeight) {
                    ballDy *= -1;
                }

                // Rebote en paletas
                // Paleta izquierda
                if (ballX <= leftPaddle.offsetLeft + leftPaddle.offsetWidth &&
                    ballY + ball.offsetHeight >= leftPaddleY &&
                    ballY <= leftPaddleY + leftPaddle.offsetHeight) {
                    ballDx *= -1;
                    ballX = leftPaddle.offsetLeft + leftPaddle.offsetWidth; // Ajustar posición para evitar que se pegue
                }
                // Paleta derecha
                if (ballX + ball.offsetWidth >= rightPaddle.offsetLeft &&
                    ballY + ball.offsetHeight >= rightPaddleY &&
                    ballY <= rightPaddleY + rightPaddle.offsetHeight) {
                    ballDx *= -1;
                    ballX = rightPaddle.offsetLeft - ball.offsetWidth; // Ajustar posición
                }

                // Anotar puntos
                if (ballX < 0) {
                    rightScore++;
                    rightScoreElem.textContent = rightScore;
                    if (rightScore >= 7) { gameOverPong('¡Perdiste!'); return; }
                    resetBall();
                } else if (ballX > pongGameDiv.offsetWidth - ball.offsetWidth) {
                    leftScore++;
                    leftScoreElem.textContent = leftScore;
                    if (leftScore >= 7) { gameOverPong('¡Ganaste!'); return; }
                    resetBall();
                }

                ball.style.left = `${ballX}px`;
                ball.style.top = `${ballY}px`;
            }

            function resetBall() {
                ballX = pongGameDiv.offsetWidth / 2 - ball.offsetWidth / 2;
                ballY = pongGameDiv.offsetHeight / 2 - ball.offsetHeight / 2;
                ballDx = (Math.random() > 0.5 ? 1 : -1) * 5; // Dirección aleatoria al reiniciar
                ballDy = (Math.random() > 0.5 ? 1 : -1) * 5;
            }

            function gameOverPong(message) {
                clearInterval(pongGameInterval);
                pongGamePaused = true;
                alert(`¡Fin del juego! ${message}`);
            }

            function togglePongPause() {
                pongGamePaused = !pongGamePaused;
                if (!pongGamePaused) {
                    pongGameInterval = setInterval(updatePongGame, 1000 / 60); // 60 FPS
                    console.log('Juego de Pong reanudado');
                } else {
                    clearInterval(pongGameInterval);
                    console.log('Juego de Pong pausado');
                }
            }

            function resetPongGame() {
                clearInterval(pongGameInterval);
                initializePongGame(); // Re-inicializar todo el juego
                pongGameInterval = setInterval(updatePongGame, 1000 / 60);
            }

            // Exponer controles
            window.activeGameControls = {
                up: () => { leftPaddleY -= paddleSpeed; },
                down: () => { leftPaddleY += paddleSpeed; },
                // ASWD también controla la paleta izquierda
                w: () => { leftPaddleY -= paddleSpeed; },
                s: () => { leftPaddleY += paddleSpeed; },
                action1: togglePongPause, // Iniciar/Pausar
                action2: resetPongGame // Reiniciar
            };

            // Iniciar el juego automáticamente
            clearInterval(pongGameInterval); // Asegurarse de que no hay otro intervalo corriendo
            pongGameInterval = setInterval(updatePongGame, 1000 / 60); // 60 FPS
        }

        // Game 4: Flappy Bird
        let flappyGameInterval;
        let flappyBirdGameStarted = false;
        let birdY;
        let birdVelocity;
        let pipes;
        let flappyScore;

        function initializeFlappyBirdGame() {
            const gameArea = document.getElementById('flappy-game');
            const bird = document.getElementById('bird');
            if (!gameArea || !bird) return;

            // Restablecer posiciones y estados iniciales
            bird.style.top = '200px';
            bird.style.left = '50px';
            // Limpiar tuberías previas
            gameArea.querySelectorAll('.pipe').forEach(p => p.remove());

            birdY = 200;
            birdVelocity = 0;
            const gravity = 0.5;
            const flapStrength = -8;
            pipes = [];
            flappyScore = 0;
            flappyBirdGameStarted = false; // El juego empieza al primer aleteo

            function createPipe() {
                const pipeHeight = Math.floor(Math.random() * (gameArea.offsetHeight / 2 - 50)) + 50; // Altura aleatoria del hueco
                const gap = 120; // Tamaño del hueco entre tuberías

                const topPipe = document.createElement('div');
                topPipe.classList.add('pipe', 'top');
                topPipe.style.height = `${pipeHeight}px`;
                topPipe.style.left = `${gameArea.offsetWidth}px`;

                const bottomPipe = document.createElement('div');
                bottomPipe.classList.add('pipe', 'bottom');
                bottomPipe.style.height = `${gameArea.offsetHeight - pipeHeight - gap}px`;
                bottomPipe.style.left = `${gameArea.offsetWidth}px`;

                gameArea.appendChild(topPipe);
                gameArea.appendChild(bottomPipe);

                pipes.push({ top: topPipe, bottom: bottomPipe, passed: false });
            }

            function updateFlappyBirdGame() {
                if (!flappyBirdGameStarted) return; // No actualizar si no ha comenzado

                birdVelocity += gravity;
                birdY += birdVelocity;
                bird.style.top = `${birdY}px`;

                // Game Over si golpea el suelo o el techo
                if (birdY <= 0 || birdY >= gameArea.offsetHeight - bird.offsetHeight) {
                    gameOverFlappy();
                    return;
                }

                // Mover y crear tuberías
                pipes.forEach(pipePair => {
                    pipePair.top.style.left = `${pipePair.top.offsetLeft - 3}px`;
                    pipePair.bottom.style.left = `${pipePair.bottom.offsetLeft - 3}px`;

                    // Eliminar tuberías fuera de pantalla
                    if (pipePair.top.offsetLeft + pipePair.top.offsetWidth < 0) {
                        pipePair.top.remove();
                        pipePair.bottom.remove();
                        pipes = pipes.filter(p => p !== pipePair); // Remover del array
                    }

                    // Detección de colisión con tuberías
                    // (birdX < pipeRight && birdRight > pipeX) && (birdY < pipeBottom || birdBottom > pipeY)
                    const birdRight = bird.offsetLeft + bird.offsetWidth;
                    const birdBottom = birdY + bird.offsetHeight;
                    const pipeTopX = pipePair.top.offsetLeft;
                    const pipeTopRight = pipeTopX + pipePair.top.offsetWidth;
                    const pipeTopBottom = pipePair.top.offsetHeight;
                    const pipeBottomX = pipePair.bottom.offsetLeft;
                    const pipeBottomRight = pipeBottomX + pipePair.bottom.offsetWidth;
                    const pipeBottomTop = gameArea.offsetHeight - pipePair.bottom.offsetHeight;

                    if (birdRight > pipeTopX && bird.offsetLeft < pipeTopRight) {
                        if (birdY < pipeTopBottom || birdBottom > pipeBottomTop) {
                            gameOverFlappy();
                            return;
                        }
                    }

                    // Aumentar puntuación
                    if (bird.offsetLeft > pipeTopRight && !pipePair.passed) {
                        flappyScore++;
                        console.log('Flappy Score:', flappyScore);
                        pipePair.passed = true;
                    }
                });

                // Crear nuevas tuberías (cuando la última tubería visible está a la mitad)
                if (pipes.length === 0 || pipes[pipes.length - 1].top.offsetLeft < gameArea.offsetWidth / 2) {
                    createPipe();
                }
            }

            function flap() {
                if (!flappyBirdGameStarted) {
                    flappyBirdGameStarted = true;
                    clearInterval(flappyGameInterval); // Asegurarse de que solo haya un intervalo
                    flappyGameInterval = setInterval(updateFlappyBirdGame, 1000 / 60); // 60 FPS
                    createPipe(); // La primera tubería se crea al iniciar el juego
                }
                birdVelocity = flapStrength;
            }

            function gameOverFlappy() {
                clearInterval(flappyGameInterval);
                flappyBirdGameStarted = false;
                alert(`¡Flappy Bird! Puntuación: ${flappyScore}. Haz clic para reiniciar.`);
                initializeFlappyBirdGame(); // Reinicia la UI y espera el nuevo "flap"
            }

            // Exponer controles
            window.activeGameControls = {
                action1: flap, // Espacio o botón de acción para aletear
                action2: () => { // Reiniciar
                    gameOverFlappy(); // Detiene el juego si está corriendo y lo reinicia
                }
            };

            // Evento de clic en el área de juego para aletear
            gameArea.onclick = flap;

            // Al inicializar el juego, esperamos el primer aleteo para empezar
            // (esto es lo que significa flappyBirdGameStarted = false;)
        }

        // Game 5: Breakout
        let breakoutGameInterval = null; // Para el intervalo de juego
        let breakoutCanvas, breakoutCtx;
        let breakoutPaddle, breakoutBall, breakoutBricks;
        let breakoutScore, breakoutLives;
        let breakoutGameActive = false; // Para controlar si el juego está en marcha
        const brickConfig = {
            rowCount: 5,
            columnCount: 8,
            width: 40,
            height: 15,
            padding: 5,
            offsetTop: 30,
            offsetLeft: 30
        };

        function initializeBreakoutGame() {
            breakoutCanvas = document.getElementById('breakout-canvas');
            if (!breakoutCanvas) return;
            breakoutCtx = breakoutCanvas.getContext('2d');

            breakoutPaddle = {
                x: breakoutCanvas.width / 2 - 40,
                y: breakoutCanvas.height - 20,
                width: 80,
                height: 10,
                dx: 0, // Movimiento horizontal actual
                speed: 7
            };

            breakoutBall = {
                x: breakoutCanvas.width / 2,
                y: breakoutPaddle.y - 10,
                radius: 7,
                dx: 4 * (Math.random() > 0.5 ? 1 : -1), // Dirección horizontal aleatoria
                dy: -4 // Siempre hacia arriba al inicio
            };

            breakoutBricks = [];
            breakoutScore = 0;
            breakoutLives = 3;
            breakoutGameActive = false; // El juego empieza al primer 'action1' o 'play-btn'

            createBreakoutBricks(); // Generar los ladrillos inicialmente
            drawBreakoutGame(); // Dibujar el estado inicial

            // Exponer controles
            window.activeGameControls = {
                left: () => { if (breakoutGameActive) breakoutPaddle.dx = -breakoutPaddle.speed; },
                right: () => { if (breakoutGameActive) breakoutPaddle.dx = breakoutPaddle.speed; },
                a: () => { if (breakoutGameActive) breakoutPaddle.dx = -breakoutPaddle.speed; },
                d: () => { if (breakoutGameActive) breakoutPaddle.dx = breakoutPaddle.speed; },
                stopMove: () => { breakoutPaddle.dx = 0; }, // Detiene el movimiento
                action1: toggleBreakoutGame, // Iniciar/Pausar
                action2: resetBreakoutGame // Reiniciar
            };
        }

        function createBreakoutBricks() {
            breakoutBricks = [];
            for (let c = 0; c < brickConfig.columnCount; c++) {
                breakoutBricks[c] = [];
                for (let r = 0; r < brickConfig.rowCount; r++) {
                    breakoutBricks[c][r] = { x: 0, y: 0, status: 1 }; // Status 1 = visible
                }
            }
        }

        function drawPaddle() {
            breakoutCtx.fillStyle = '#fff';
            breakoutCtx.fillRect(breakoutPaddle.x, breakoutPaddle.y, breakoutPaddle.width, breakoutPaddle.height);
        }

        function drawBall() {
            breakoutCtx.beginPath();
            breakoutCtx.arc(breakoutBall.x, breakoutBall.y, breakoutBall.radius, 0, Math.PI * 2);
            breakoutCtx.fillStyle = '#ff0050';
            breakoutCtx.fill();
            breakoutCtx.closePath();
        }

        function drawBricks() {
            for (let c = 0; c < brickConfig.columnCount; c++) {
                for (let r = 0; r < brickConfig.rowCount; r++) {
                    if (breakoutBricks[c][r].status === 1) {
                        const brickX = (c * (brickConfig.width + brickConfig.padding)) + brickConfig.offsetLeft;
                        const brickY = (r * (brickConfig.height + brickConfig.padding)) + brickConfig.offsetTop;
                        breakoutBricks[c][r].x = brickX;
                        breakoutBricks[c][r].y = brickY;
                        breakoutCtx.fillStyle = '#00ffaa'; // Color de los ladrillos
                        breakoutCtx.fillRect(brickX, brickY, brickConfig.width, brickConfig.height);
                    }
                }
            }
        }

        function collisionDetection() {
            for (let c = 0; c < brickConfig.columnCount; c++) {
                for (let r = 0; r < brickConfig.rowCount; r++) {
                    const b = breakoutBricks[c][r];
                    if (b.status === 1) {
                        // Simple AABB collision detection
                        if (breakoutBall.x + breakoutBall.radius > b.x && breakoutBall.x - breakoutBall.radius < b.x + brickConfig.width &&
                            breakoutBall.y + breakoutBall.radius > b.y && breakoutBall.y - breakoutBall.radius < b.y + brickConfig.height) {
                            breakoutBall.dy *= -1; // Invertir dirección vertical
                            b.status = 0; // Marcar ladrillo como destruido
                            breakoutScore++;
                            if (breakoutScore === brickConfig.rowCount * brickConfig.columnCount) {
                                gameOverBreakout("¡GANASTE, FELICIDADES!");
                                return;
                            }
                        }
                    }
                }
            }
        }

        function drawScore() {
            breakoutCtx.font = "16px Arial";
            breakoutCtx.fillStyle = "#fff";
            breakoutCtx.fillText(`Puntos: ${breakoutScore}`, 8, 20);
        }

        function drawLives() {
            breakoutCtx.font = "16px Arial";
            breakoutCtx.fillStyle = "#fff";
            breakoutCtx.fillText(`Vidas: ${breakoutLives}`, breakoutCanvas.width - 75, 20);
        }

        function drawBreakoutGame() {
            breakoutCtx.clearRect(0, 0, breakoutCanvas.width, breakoutCanvas.height); // Limpiar el canvas

            drawBricks();
            drawPaddle();
            drawBall();
            drawScore();
            drawLives();
        }

        function updateBreakoutGame() {
            if (!breakoutGameActive) return; // No actualizar si no está activo

            drawBreakoutGame(); // Dibuja el estado actual antes de mover
            collisionDetection();

            breakoutBall.x += breakoutBall.dx;
            breakoutBall.y += breakoutBall.dy;

            // Rebote en paredes laterales
            if (breakoutBall.x + breakoutBall.radius > breakoutCanvas.width || breakoutBall.x - breakoutBall.radius < 0) {
                breakoutBall.dx *= -1;
            }
            // Rebote en pared superior
            if (breakoutBall.y - breakoutBall.radius < 0) {
                breakoutBall.dy *= -1;
            }

            // Rebote en paleta
            if (breakoutBall.y + breakoutBall.radius > breakoutPaddle.y &&
                breakoutBall.x > breakoutPaddle.x &&
                breakoutBall.x < breakoutPaddle.x + breakoutPaddle.width) {
                breakoutBall.dy *= -1;
            }

            // Pelota cae al fondo
            if (breakoutBall.y + breakoutBall.radius > breakoutCanvas.height) {
                breakoutLives--;
                if (breakoutLives === 0) {
                    gameOverBreakout("¡FIN DEL JUEGO!");
                } else {
                    // Reiniciar posición de la pelota y paleta
                    breakoutBall.x = breakoutCanvas.width / 2;
                    breakoutBall.y = breakoutPaddle.y - 10;
                    breakoutBall.dx = 4 * (Math.random() > 0.5 ? 1 : -1);
                    breakoutBall.dy = -4;
                    breakoutPaddle.x = breakoutCanvas.width / 2 - 40;
                }
            }

            // Mover paleta
            breakoutPaddle.x += breakoutPaddle.dx;
            if (breakoutPaddle.x < 0) breakoutPaddle.x = 0;
            if (breakoutPaddle.x + breakoutPaddle.width > breakoutCanvas.width) {
                breakoutPaddle.x = breakoutCanvas.width - breakoutPaddle.width;
            }
        }

        function toggleBreakoutGame() {
            breakoutGameActive = !breakoutGameActive;
            if (breakoutGameActive) {
                if (!breakoutGameInterval) { // Solo iniciar si no está ya activo
                    breakoutGameInterval = setInterval(updateBreakoutGame, 1000 / 60); // 60 FPS
                    console.log('Juego de Breakout reanudado/iniciado');
                }
            } else {
                clearInterval(breakoutGameInterval);
                breakoutGameInterval = null;
                console.log('Juego de Breakout pausado');
            }
        }

        function resetBreakoutGame() {
            clearInterval(breakoutGameInterval);
            breakoutGameInterval = null; // Asegurarse de que el intervalo se limpie
            initializeBreakoutGame(); // Reinicializa todos los valores
            console.log('Juego de Breakout reiniciado');
        }

        function gameOverBreakout(message) {
            clearInterval(breakoutGameInterval);
            breakoutGameInterval = null;
            breakoutGameActive = false;
            alert(message);
            // Opcional: mostrar un botón de "Reiniciar" o volver al menú
        }


        // --- Utilidades ---

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        // Actualizar el estado móvil al cambiar el tamaño de la ventana
        window.addEventListener('resize', () => {
            isMobile = window.innerWidth <= 768;
            updateGameControlsVisibility();
            // Si tus juegos tienen tamaños de canvas dinámicos, aquí podrías redibujarlos.
            // Para juegos basados en CSS como Pong, Flappy, solo se ajustará por CSS.
        });

        // Inicializar al cargar la página
        document.addEventListener('DOMContentLoaded', () => {
            generateCarouselItems();
            generateGameSlides(); // Generar los slides y sus indicadores
            updateGameControlsVisibility(); // Establecer la visibilidad inicial de los controles móviles

            // Asegurar que los elementos estén en el estado inicial correcto
            mainMenu.classList.remove('hidden');
            appContainer.style.display = 'none';
            header.style.display = 'none';
            authModal.style.display = 'none';
            tutorialModal.style.display = 'none';
        });

        // Añadir eventos de scroll para la navegación entre juegos
        document.body.addEventListener('wheel', handleScroll, { passive: false });

        // Añadir eventos de touch para navegación en móviles
        document.body.addEventListener('touchstart', handleTouchStart, { passive: true });
        document.body.addEventListener('touchmove', handleTouchMove, { passive: true });
        document.body.addEventListener('touchend', handleTouchEnd);

        // Asignar eventos a los botones "Jugar" (después de que los slides existan en el DOM)
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('play-btn')) {
                const gameId = e.target.getAttribute('data-game-id');
                console.log(`Presionaste Jugar para: ${gameId}`);
                // Forzar reinicio/inicio del juego al presionar "Jugar"
                initializeGameSpecificContent(gameId);
                // Si el juego necesita ser "activado" después del inicio (como Flappy Bird o Breakout)
                // puedes llamar a su función de inicio aquí, si no se hace en initializeGameSpecificContent.
                if (gameId === 'game4' && !flappyBirdGameStarted) { // Flappy Bird inicia al primer 'flap'
                    // Esto está manejado por el primer clic/tecla de acción
                }
                if (gameId === 'game5' && !breakoutGameActive) {
                    toggleBreakoutGame(); // Iniciar Breakout si no está activo
                }
            }
        });

    </script>
</body>
</html>
